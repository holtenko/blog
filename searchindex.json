{"categories":[{"title":"Git","uri":"https://holtenko.github.io/blog/categories/git/"},{"title":"Java","uri":"https://holtenko.github.io/blog/categories/java/"},{"title":"Linux","uri":"https://holtenko.github.io/blog/categories/linux/"},{"title":"Shell","uri":"https://holtenko.github.io/blog/categories/shell/"},{"title":"Tools","uri":"https://holtenko.github.io/blog/categories/tools/"},{"title":"算法","uri":"https://holtenko.github.io/blog/categories/%E7%AE%97%E6%B3%95/"},{"title":"设计模式","uri":"https://holtenko.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"posts":[{"content":"安装asar npm install -g asar\n解压app.asar 进入到app.asar目录下执行当前命令。默认文件路径Windows是C:\\Program Files\\StarUML\\resources，Mac是/Applications/StarUML.app/Contents/Resources。\nasar extract app.asar app\n修改激活代码 解压之后当前文件夹下有一个新的目录app，真正的验证license的代码在app\\src\\engine\\license-manager.js，把的这两个方法替换掉。\ncheckLicenseValidity () { this.validate().then(() =\u0026gt; { setStatus(this, true) }, () =\u0026gt; { //setStatus(this, false) // UnregisteredDialog.showDialog() setStatus(this, true) }) } /** * Check the license key in server and store it as license.key file in local * * @param {string} licenseKey */ register (licenseKey) { return new Promise((resolve, reject) =\u0026gt; { $.post(app.config.validation_url, {licenseKey: licenseKey}) .done(data =\u0026gt; { var file = path.join(app.getUserPath(), '/license.key') fs.writeFileSync(file, JSON.stringify(data, 2)) licenseInfo = data setStatus(this, true) resolve(data) }) .fail(err =\u0026gt; { setStatus(this, true) //if (err.status === 499) { /* License key not exists */ // reject('invalid') //} else { // reject() //} }) }) } 重新打包替换原来的app.asar asar pack app app.asar\n启动StarUML 开始工作吧 ","id":0,"section":"posts","summary":"安装asar npm install -g asar 解压app.asar 进入到app.asar目录下执行当前命令。默认文件路径Windows是C:\\Program Files","tags":["Linux","Wiki"],"title":"StarUML 3.0.1 激活教程","uri":"https://holtenko.github.io/blog/2018/07/30/staruml-activate/","year":"2018"},{"content":"系列回顾  没事学点设计模式-概览 没事学点设计模式-工厂模式 没事学点设计模式-抽象工厂模式  简介 单例模式（Singleton Pattern）可以说是Java中最简单的设计模式。这种类型的设计模式属于创建型模式，它提供了一种创建一个全局唯一对象的最佳方式，可以避免一个全局使用的对象，尤其是大对象，的频繁创建与销毁。\n这种模式涉及到一个单一的类，该类负责创建自己的对象实例，同时确保只有一个对象实例被创建。这个类提供了访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。这就意味着单例类只能有一个实例，而且必须自己给自己创建唯一的实例，同时必须给其他所有对象提供这一实例。\n优点\n 在单例模式中，对单例类的所有实例化得到的都是相同的一个实例，可以确保所有的对象都访问同一个实例。 类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。 提供了对唯一实例的受控访问。 由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象，特别是大对象时可以提高系统的性能。 避免对共享资源的多重占用。  缺点\n 无法继承，扩展比较困难。 不适用于变化的对象。  实例 单例模式的实现有非常多，但是有些是线程安全的，有些是线程不安全的，这里仅介绍几种线程安全的实现方法。\n懒汉式 这种方式可以实现懒加载，线程安全，但是会存在效率问题，因为绝大多数情况下是不需要同步加锁的。\n代码如下：\npublic class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } } 饿汉式 这种方式基于classloader机制避免了线程安全问题，但是实例在类加载时就实例化了，可能会产生垃圾对象。\n代码如下：\npublic class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } } 双重校验式 这种方式采用双重校验锁的机制，可以保证线程安全且可以保证较好的性能。\n代码如下：\npublic class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } } 静态内部类式 这种方式和饿汉式采用相同的机制来保证线程安全，但是通过静态内部类的形式实现了懒加载，避免了垃圾对象的产生。\n代码如下：\npublic class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } } 枚举式 这种方式在实际使用中很少被采用，但是这确实是目前实现单例最好的方式，简洁，自动支持序列化机制，绝对防止多次实例化，也无法通过反射调用构造函数的方式来创建实例。\n代码如下：\npublic enum Singleton { INSTANCE; public void yourMethod() { } } 本文源码已托管至GitHub，欢迎Star 抽象工厂模式源码：https://github.com/holtenko/DesignPatterns/tree/master/src/Singleton\n","id":1,"section":"posts","summary":"系列回顾 没事学点设计模式-概览 没事学点设计模式-工厂模式 没事学点设计模式-抽象工厂模式 简介 单例模式（Singleton Pattern）可以说","tags":["设计模式"],"title":"没事学点设计模式-单例模式","uri":"https://holtenko.github.io/blog/2018/03/22/design-pattern-4/","year":"2018"},{"content":"The content of element type \u0026ldquo;web-app\u0026rdquo; must match 问题原因 web.xml中\u0026lt;web-app\u0026gt;标签的元素个数和排序规则是有限制的，大多数情况下出现该错误的原因是元素排放顺序有误。\n解决方法 解决其实也很简单，按照要求将各元素排序即可，具体排序如下：\n\u0026lt;!-- The web-app element is the root of the deployment descriptor for a web application. --\u0026gt; \u0026lt;!ELEMENT web-app (icon?, display-name?, description?, distributable?, context-param*, filter*, filter-mapping*, listener*, servlet*, servlet-mapping*, session-config?, mime-mapping*, welcome-file-list?, error-page*, taglib*, resource-env-ref*, resource-ref*, security-constraint*, login-config?, security-role*, env-entry*, ejb-ref*, ejb-local-ref*)\u0026gt; ","id":2,"section":"posts","summary":"The content of element type \u0026ldquo;web-app\u0026rdquo; must match 问题原因 web.xml中\u0026lt;web-app\u0026gt;标签的元素个数和排序规则是有限制的，大多数情况下出现该错误的原因是元素","tags":["Java","Spring","Wiki"],"title":"web.xml配置过程中的常见错误","uri":"https://holtenko.github.io/blog/2018/02/24/web-xml-error/","year":"2018"},{"content":"系列回顾  没事学点设计模式-概览 没事学点设计模式-工厂模式  简介 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。\n举例说明 iPhone 8和iPhone X的屏幕和外壳都是不一样的，通过抽象工厂模式就可以实现，在为iPhone生产配件的时候不用指定相关的型号，可以自动根据手机的型号生产相应的配件。\n优点 当一个系列中的多个对象被设计成一起工作时，它能保证调用时始终只使用同一个系列中的对象，而不需要去指定具体的型号。\n缺点 系列扩展非常困难，要增加一个系列的某一产品时，既要在抽象的 Factory 里加代码，又要在具体的实现里面加代码。比如后面发现iPhone X配AirPods，iPhone 8配EarPods，那么不仅要Factory接口中添加方法，还要在其实现类中去修改。\n使用场景\n 软件的更换界面主题功能； 生成不同操作系统的软件；  实例 1.首先需要创建一个Screen、Shell接口和其实现类：\npublic interface Screen { void build(); } public class Screen8 implements Screen { @Override public void build() { System.out.println(\u0026quot;iphone 8 screen get!\u0026quot;); } } public class ScreenX implements Screen { @Override public void build() { System.out.println(\u0026quot;iphone X screen get!\u0026quot;); } } public interface Shell { void build(); } public class Shell8 implements Shell { @Override public void build() { System.out.println(\u0026quot;iphone 8 shell get!\u0026quot;); } } public class ShellX implements Shell { @Override public void build() { System.out.println(\u0026quot;iphone X shell get!\u0026quot;); } } 2.然后定义抽象工厂接口IphoneFactory\npublic interface IphoneFactory { Screen getScreen(); Shell getShell(); } 3.实现相应的工厂\npublic class Iphone8Factory implements IphoneFactory { @Override public Screen getScreen() { return new Screen8(); } @Override public Shell getShell() { return new Shell8(); } } public class IphoneXFactory implements IphoneFactory { @Override public Screen getScreen() { return new ScreenX(); } @Override public Shell getShell() { return new ShellX(); } } 4.可以生产了\npublic class AbstractFactoryDemo { public static void main(String[] args) { IphoneFactory factory = new IphoneXFactory(); Screen screen = factory.getScreen(); Shell shell = factory.getShell(); screen.build(); shell.build(); } } 本文源码已托管至GitHub，欢迎Star 抽象工厂模式源码：https://github.com/holtenko/DesignPatterns/tree/master/src/AbstractFactory\n","id":3,"section":"posts","summary":"系列回顾 没事学点设计模式-概览 没事学点设计模式-工厂模式 简介 抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。","tags":["设计模式","抽象工厂模式"],"title":"没事学点设计模式-抽象工厂模式","uri":"https://holtenko.github.io/blog/2018/02/12/design-pattern-3/","year":"2018"},{"content":" fork 原始仓库 clone 自己的仓库 在 master 分支添加原始仓库为远程分支 git remote add upstream 远程仓库 自己分支开发，如 dev 分支开发：git checkout -b dev 本地 dev 提交 切换 master 分支，同步原始仓库：git checkout master， git pull upstream master 切换本地 dev 分支，合并本地 master 分支（已经和原始仓库同步），可能需要解冲突 提交本地 dev 分支到自己的远程 dev 仓库 现在才是给原始仓库发 pull request 请求 等待原作者回复（接受/拒绝）  ","id":4,"section":"posts","summary":"fork 原始仓库 clone 自己的仓库 在 master 分支添加原始仓库为远程分支 git remote add upstream 远程仓库 自己分支开发，如 dev 分支开发：git checkout -b dev 本地 dev 提交 切换 master 分支，同步原始仓","tags":["Git","Wiki"],"title":"如何正确地给 github 的开源项目提交 pull request","uri":"https://holtenko.github.io/blog/2018/01/30/pullrequest-github/","year":"2018"},{"content":"HTTP Status 500 - java.lang.IllegalStateException: No output folder 原因 此错误一般是由于解压缩版的Tomcat没有合理分配权限导致的。\n解决方案 可通过修改Tomcat目录权限，或修改其拥有者来解决。\n 修改Tomcat目录权限：sudo chmod -R 777 $TOMCAT_HOME。 修改拥有者：sudo chown -R yourUserName $TOMCAT_HOME。  ","id":5,"section":"posts","summary":"HTTP Status 500 - java.lang.IllegalStateException: No output folder 原因 此错误一般是由于解压缩版的Tomcat没有合理分配权限导致的。 解决方案 可通过修改Tomcat目录权限，或修改其拥有者来解","tags":["Java","Tomcat","Error","Wiki"],"title":"Tomcat常见错误","uri":"https://holtenko.github.io/blog/2018/01/30/tomcat-errors/","year":"2018"},{"content":"Ctrl+Shift+方向键Up/Down 代码向上/下移动\nCtrl+X 删除行\nCtrl+Y 也是删除行，不知道有啥区别\nCtrl+D 复制行\nCtrl+Alt+L 格式化代码\nCtrl+N 查找类\nCtrl+Shift+N 查找文件\nAlt+Enter 智能导入包，自动修正\nCtrl+Alt+O 优化导入的类和包\nAlt+Insert 生成代码(如get，set方法，构造函数等)\nCtrl+E 最近更改的文件\nAlt+Shift+C 最近更改的代码\nCtrl+Shift+Space 自动补全代码\nCtrl+Alt+Space 类名或接口名提示\nCtrl+空格 代码提示(Windows下这个会被占用)\nCtrl+P 方法参数提示\nCtrl+Shift+Alt+N 查找类中的方法或变量\nCtrl+R 文件内替换文本\nCtrl+F 文件内查找文本\nShift+F6 重构-重命名\nCtrl+/ 注释//\nCtrl+Shift+/ 注释/\u0026hellip;/\nCtrl+J 自动代码\nCtrl+H 显示类结构图(继承关系)\nAlt+F1 查找代码所在位置\nAlt+1 快速打开或隐藏工程面板\nCtrl+Alt+ left/right 返回至上次浏览的位置\nAlt+ left/right 切换代码Tab\nAlt+ Up/Down 移动到上一个/下一个方法\nF2 警告快速定位\nCtrl+W 选中代码，连续按会有其他效果\nCtrl+Up/Down 光标跳转到第一行或最后一行\nCtrl+B或Ctrl+左键 快速打开光标处的类或方法\nShift＋左键 可以关闭文件\nCtrl＋Shift＋Backspace 可以跳转到上次编辑的地方\nCtrl＋F12 可以显示当前文件的结构\nCtrl＋F7 可以查询当前元素在当前文件中的引用，然后按F3可以选择\nCtrl＋Shift＋Insert 可以选择剪贴板内容并插入\nCtrl＋Alt＋V 可以把括号内的内容抽离为一个变量\nCtrl＋Alt＋T 可以把代码包在一块内，例如try/catch\nCtrl＋O 可以选择父类的方法进行重写\nCtrl＋Shift＋J 可以整合两行\n","id":6,"section":"posts","summary":"Ctrl+Shift+方向键Up/Down 代码向上/下移动 Ctrl+X 删除行 Ctrl+Y 也是删除行，不知道有啥区别 Ctrl+D 复制行 Ctrl+Alt+L 格式化代码 Ctrl+N 查找类 Ctrl+Shift+N 查找文件 Alt+Enter 智能导","tags":["Tools","Wiki"],"title":"IntelliJIdea快捷键","uri":"https://holtenko.github.io/blog/2018/01/23/intellij-idea-keymap/","year":"2018"},{"content":"系列回顾  没事学点设计模式-概览  简介 工厂模式（Factory Pattern）是一种最常用的设计模式。这种类型的设计模式属于创建型模式，它提供了一种方便快捷创建对象的最佳方式。\n在工厂模式中，我们在创建对象时不需要向调用方暴露创建对象的具体逻辑流程，并且是通过使用一个共同的接口来指向新创建的对象。工厂模式定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行，用以解决接口选择的问题。\n举例说明\n 我要买一辆汽车，我可以直接从工厂里面提货，而不用去关心这辆汽车是如何生产出来的，以及这个汽车里面的各种细节是什么样子的。 我要买一部手机，我也不需要知道手机是怎么制造出来的，我只需要知道我想要iPhoneX还是还是HUAWEI P10，工厂自然会帮我制造出来。  优点\n 创建一个对象，只要知道其名称就可以了，就比如我只需要知道那款手机叫iPhoneX就可以了； 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以了； 屏蔽具体实现，用户只关心接口即可。  缺点 每增加一个实现时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。\n使用场景\n 日志记录器：记录可能记录到本地文件、远程服务器、打印到终端等，用户只需要知道要记录到哪里说明即可。 数据库访问：当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时，现在是Oracle，有可能换到MySQL等，此时只需换方言和驱动就可以。 设计一个连接服务器的框架，可以通过\u0026quot;TCP\u0026quot;或者\u0026quot;UDP\u0026quot;或者其他协议,可以把这些都作为产品类，共同实现一个接口即可。  实例 我们以生产iPhone的生产工厂为例。\n简单工厂模式 1.首先需要创建一个iphone接口和其实现类：接口iphone，实现类iphone7\\iphone8\\iphonex；\npublic interface Iphone { void build(); } public class Iphone7 implements Iphone { @Override public void build() { System.out.println(\u0026quot;iphone7 get!\u0026quot;); } } public class Iphone8 implements Iphone { @Override public void build() { System.out.println(\u0026quot;iphone8 get!\u0026quot;); } } public class Iphonex implements Iphone { @Override public void build() { System.out.println(\u0026quot;iphonex get!\u0026quot;); } } 2.然后定义工厂类iphoneFactory\npublic class IphoneFactory { public Iphone getIphone(String iphoneType) { if (iphoneType == null) { return null; } if (iphoneType.equalsIgnoreCase(\u0026quot;iphone7\u0026quot;)) { return new Iphone7(); } else if (iphoneType.equalsIgnoreCase(\u0026quot;iphone8\u0026quot;)) { return new Iphone8(); } else if (iphoneType.equalsIgnoreCase(\u0026quot;iphonex\u0026quot;)) { return new Iphonex(); } return null; } } 3.然后就可以随意生产了，比如先来一个iphonex哈哈哈\npublic class FactoryDemo { public static void main(String[] args) { IphoneFactory iphonefactory = new IphoneFactory(); Iphone iphone = iphonefactory.getIphone(\u0026quot;iphonex\u0026quot;); iphone.build(); } } 工厂方法模式 1.首先需要创建一个iphone接口和其实现类：接口iphone，实现类iphone7\\iphone8\\iphonex；\npublic interface Iphone { void build(); } public class Iphone7 implements Iphone { @Override public void build() { System.out.println(\u0026quot;iphone7 get!\u0026quot;); } } public class Iphone8 implements Iphone { @Override public void build() { System.out.println(\u0026quot;iphone8 get!\u0026quot;); } } public class Iphonex implements Iphone { @Override public void build() { System.out.println(\u0026quot;iphonex get!\u0026quot;); } } 2.然后定义工厂接口iphoneFactory\npublic interface IphoneFactory { public Iphone getIphone()； } 3.实现工厂接口\npublic class Iphone7Factory implements IphoneFactory { @Override public Iphone getIphone() { return new Iphone7(); } } public class Iphone8Factory implements IphoneFactory { @Override public Iphone getIphone() { return new Iphone8(); } } public class IphonexFactory implements IphoneFactory { @Override public Iphone getIphone() { return new Iphonex(); } } 3.然后就也可以随意生产了，比如再来一个iphone8\npublic class FactoryDemo { public static void main(String[] args) { IphoneFactory iphonefactory = new Iphone8Factory(); Iphone iphone = iphonefactory.getIphone(); iphone.build(); } } 本文源码已托管至GitHub，欢迎Star 工厂模式源码：https://github.com/holtenko/DesignPatterns/tree/master/src/Factory\n","id":7,"section":"posts","summary":"系列回顾 没事学点设计模式-概览 简介 工厂模式（Factory Pattern）是一种最常用的设计模式。这种类型的设计模式属于创建型模式，它提供了","tags":["设计模式"],"title":"没事学点设计模式-工厂模式","uri":"https://holtenko.github.io/blog/2017/09/29/design-pattern-2/","year":"2017"},{"content":"227 Entering Passive Mode 响应: 227 Entering Passive Mode (192,168,1,16,221,111). 命令: LIST 错误: 连接超时 错误: 读取目录列表失败 解决方法：\n 打开/etc/vsftpd/vsftpd.conf在最后面加入如下：  pasv_min_port=1 pasv_max_port=30999 在iptable防火墙规则中加入如下规则： 打开/etc/sysconfig/iptables加入如下：  -A INPUT -m state –state NEW -m tcp -p tcp –dport 1:30999 -j ACCEPT 重启vsftp和iptables服务了。   重启vsftp服务service vsftpd restart 重启iptables服务service iptables restart  ","id":8,"section":"posts","summary":"227 Entering Passive Mode 响应: 227 Entering Passive Mode (192,168,1,16,221,111). 命令: LIST 错误: 连接超时 错误: 读取目录列表失败 解决方法： 打开/etc/vsftpd/vsftpd.conf在最后面加入","tags":["Linux","FTP","Wiki","Error"],"title":"FTP常见错误及解决方案","uri":"https://holtenko.github.io/blog/2017/09/18/ftp-errors-and-solutions/","year":"2017"},{"content":"安装vsftpd yum install vsftpd 启动/重启/关闭vsftpd服务器 CentOS7 以下：\n 启动: service vsftpd start 停止: service vsftpd stop 重启: service vsftpd restart 执行完成后可以使用service vsftpd status查看运行状态 CentOS7： 启动: /bin/systemctl start vsftpd.service 停止: /bin/systemctl stop vsftpd.service 重启: /bin/systemctl restart vsftpd.service 执行完成后可以使用/bin/systemctl status vsftpd.service查看状态  与vsftpd服务器有关的文件和文件夹  vsftpd服务器的配置文件的是: /etc/vsftpd/vsftpd.conf  定制进入FTP服务器的欢迎信息 在vsftpd.conf文件中设置:dirmessage_enable=yes,然后进入用户目录建立一个.message文件,输入欢迎信息即可。\n设置开机启动 找到/etc/rc.local文件，在最后一行添加：service vsftpd start ,保存，退出\n配置vsftpd.conf anonymous_enable=NO #禁止匿名 local_enable=YES #允许本地登录 write_enable=YES #允许写，如需上传，则必须 local_umask=027 #将上传文件的权限设置为：777-local_umask anon_upload_enable=YES # 允许虚拟用户和匿名用户上传 anon_other_write_enable=YES #允许虚拟用户和匿名用户修改文件名和删除文件 dirmessage_enable=YES xferlog_enable=YES #打开日志记录 connect_from_port_20=YES xferlog_file=/var/log/vsftpd.log #日志存放位置 xferlog_std_format=YES #标准日志格式 idle_session_timeout=600 #空闲连接超时 data_connection_timeout=120 ftpd_banner=Welcome to Holten FTP service #欢迎信息 guest_enable=yes #允许虚拟用户 guest_username=vsftpdguest #虚拟用户使用的系统账号 virtual_use_local_privs=YES #虚拟用户拥有本地系统权限 chroot_local_user=NO chroot_list_enable=YES #以上两行将虚拟用户限制在其目录下，不能访问其他目录，或者直接用 chroot_local_user=YES listen=yes #监听/被动模式 listen_port=21 #监听端口 chroot_list_file=/etc/vsftpd/vsftpd.chroot_list #虚拟用户名单保存在文件 /etc/vsftpd/vsftpd.chroot_list 中 user_config_dir=/etc/vsftpd/vsftpd_user_conf #每个虚拟用户名的更加详细的配置保存在 /etc/vsftpd/vsftpd_user_conf 中 ","id":9,"section":"posts","summary":"安装vsftpd yum install vsftpd 启动/重启/关闭vsftpd服务器 CentOS7 以下： 启动: service vsftpd start 停止: service vsftpd stop 重启: service vsftpd restart 执行完成后可以使用service vsftpd sta","tags":["Linux","FTP","Wiki"],"title":"CentOS下FTP服务器安装与配置","uri":"https://holtenko.github.io/blog/2017/09/17/ftp-install-centos/","year":"2017"},{"content":"目前，Mac内置的Vim是7.3版本的，而且还缺少很多功能，下面介绍如何通过源码安装更新最新版本的Vim，同时保留系统内置的Vim。\n# 下载Vim源代码 git clone https://github.com/vim/vim.git # 进入源码的src目录 cd vim/src #配置、安装 ./configure --enable-pythoninterp make make install # 卸载的话 make uninstall 此时，Vim被安装在了/usr/local/bin下，重启终端后，可以通过which vim查看。\n此时，一般来说在终端里执行vim命令的话就应该是新版本的vim了，需要说明的是，这是因为系统内置的vim在/usr/bin目录下，而$PATH里/usr/local/bin在/usr/bin之前，所以系统会先找到刚安装的vim，所以如果你发现没有使用新版本的vim，请echo $PATH查看确认。\n","id":10,"section":"posts","summary":"目前，Mac内置的Vim是7.3版本的，而且还缺少很多功能，下面介绍如何通过源码安装更新最新版本的Vim，同时保留系统内置的Vim。 # 下载V","tags":["Tools","Mac","Wiki"],"title":"Mac下更新Vim到最新版本","uri":"https://holtenko.github.io/blog/2017/09/16/update-vim-mac/","year":"2017"},{"content":"系统安装  格式化内存卡。一定要为FAT32，Windows下32G以上内存卡可用guiformat-x64.exe格式化。 将NOOBS_v2_0_0.zip解压，然后将解压后的文件夹内的所有文件复制到内存卡。 将内存卡插入树莓派，使用5V，至少2A以上电源供电，连接显示器，启动树莓派。 在此选择默认的Raspbian，点击Install进行安装。  系统更新  连接网络，确认网络可用。 命令行执行sudo apt-get update 命令行执行sudo apt-get upgrade  配置常用环境 语言环境 Preference-Raspberry Pi Configuration-Localisation-Set Locale...\n选择zh(Chinese)。 ==== 时区环境 ==== Preference-Raspberry Pi Configuration-Localisation-Set Timezone...\n选择Asia，Shanghai。\n其它环境 开启Preference-Raspberry Pi Configuration-Interface-SSH。\n其它如Keyboard，WiFi Country自己设置一下为China。\nJava环境配置  Java路径：/usr/lib/jvm/jdk-x-xxx，具体路径的最后一层可能会有更新。 配置环境变量vim /etc/profile,在文件最后添加如下内容  export JAVA_HOME=/usr/lib/jvm/jdk-x-xxx export JRE_HOME=$JAVA_HOME/jre export PATH=$PATH:$JAVA_HOME/bin export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib 保存文件，然后执行以下source /etc/profile,使配置文件生效即可。\n","id":11,"section":"posts","summary":"系统安装 格式化内存卡。一定要为FAT32，Windows下32G以上内存卡可用guiformat-x64.exe格式化。 将NOOBS_v2_","tags":["Linux","Raspberry","Wiki"],"title":"树莓派系统安装配置","uri":"https://holtenko.github.io/blog/2017/09/13/raspberry-setup/","year":"2017"},{"content":"做项目的时候有可能会经常发生这样的事情，就是要在静态方法里面调用其他类的方法，如果直接new一个出来的话，有可能会造成该类和该类里面的其他依赖类无法正常的注入，如果直接@Autowired在这个静态变量上的话会造成该变量还是null。\n为什么呢？ 因为静态变量不是一个对象，只是类的引用，而类被加载字节码的时候，变量已经初始化了，也就是给该变量分配内存了，导致spring忽略静态变量。\n如何解决呢？ 可以使用setter方法来注入，如下：\nprivate static UserService userService； @Autowired public void setUserService(UserService service) { userService = service; } 这样就可以正常的进行依赖注入了。\n","id":12,"section":"posts","summary":"做项目的时候有可能会经常发生这样的事情，就是要在静态方法里面调用其他类的方法，如果直接new一个出来的话，有可能会造成该类和该类里面的其他依","tags":["Java","Spring","Wiki"],"title":"静态变量的自动注入值","uri":"https://holtenko.github.io/blog/2017/09/12/static-variables-di/","year":"2017"},{"content":"标题 在这段文字前加 # 号即可。\n# 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。\n列表 列表的显示只需要在文字前加上 - 或 * 即可变为无序列表 有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。\n引用 在文本前加入 \u0026gt; 这种尖括号（大于号）即可.\n\u0026gt; 例如这样 图片与链接 插入链接与插入图片的语法很像，区别在一个 !号 图片为：![Title](图片URL) 链接为：[Title](URL)\n粗体与斜体 用两个 * 包含一段文本就是粗体的语法 用一个 * 包含一段文本就是斜体的语法。\n表格 | col1 | col2 | col3 | | ------------- |:-------------:| -----:| | 1 | centered | 3 | | 2 | centered | 4 | | 3 | | 5 | 行内代码 用两个 ` 把中间的代码包裹起来。\n代码块 前后各三`把中间的代码包起来即可。\n分割线 分割线的语法只需要三个 * 号。\n","id":13,"section":"posts","summary":"标题 在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题 以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表 列表的显示","tags":["Tools","Wiki","Markdown"],"title":"markdown语法","uri":"https://holtenko.github.io/blog/2017/09/11/markdown-syntax/","year":"2017"},{"content":"什么是设计模式 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。设计模式使代码编制真正工程化，可以说设计模式是软件工程的基石。合理的使用设计模式可以使我们的代码具有更强的复用性和灵活的扩展性，这里面蕴含了很多前辈的经验，可以帮助我们少走很多弯路，完美地解决很多问题。\n有哪些设计模式 根据GOF所著的《设计模式-可复用的面向对象软件元素》中提到，共有23种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。\n   模式 描述 细分类型     创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活. 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern建造者模式（Builder Pattern）原型模式（Prototype Pattern）   结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）   行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）    设计模式的原则  开闭原则（Open Close Principle） 对扩展开放，对修改关闭。在程序需要进行扩展的时候，不去修改原代码，实现热插拔效果。目的是为了使程序的扩展性好，易于维护和升级。为此需要使用接口和抽象类。 里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。这个原则是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 依赖反转原则（Dependence Inversion Principle） 这是开闭原则的基础。针对接口编程，依赖于抽象而不依赖于具体。 接口隔离原则（Interface Segregation Principle） 使用多个隔离的接口，比使用单个接口要好。此外还可以降低类之间的耦合度。 迪米特法则，又称最少知道原则（Demeter Principle） 一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 合成复用原则（Composite Reuse Principle） 尽量使用合成/聚合的方式，而不是使用继承。  后面的文章会详细介绍其中部分设计模式\n","id":14,"section":"posts","summary":"什么是设计模式 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。设计模式使代码编制真正工程化，可以说设计模式是软","tags":["设计模式"],"title":"没事学点设计模式-概览","uri":"https://holtenko.github.io/blog/2017/09/11/design-pattern-1/","year":"2017"},{"content":"什么是Spring Boot 读研期间主要写的是Java后端，工作之后开始更多地接触Node.js写后端程序，有对比才有伤害，让我深深的感受到了Java的重量级，开发的时候各种配置，部署的时候还有一堆要忙活，相对而言Node.js之类的新兴的后端语言显得格外的清新小巧。如果你觉得既然如此就可以就此放弃Java了，那就太草率了，毕竟Java作为后端主流语言不会就这么自甘堕落，Spring Boot应运而生，虽然很早之前就听过Spring Boot的大名，但是碍于当时论文的压力，一直没有深入地去了解，最近项目需要正好可以搞一搞熟悉一下。\nSpring Boot推崇的是”习惯优于配置“，通俗的说可以这么理解，原来一个即使很简单的项目也需要有一大把的配置，但是后来发现很多时候大部分的配置都是一样的，你也会这么配，我也会这么配，但是如果你不知道你就不会配，你仍然需要去了解茫茫多的配置项才能运行一个其实非常简单的项目，当你陷入这种境地的时候，Spring Boot就给你带来了曙光，你可以摆脱大部分的通用配置，框架内置一套习惯的配置，你只需要对你需要的部分进行定制即可。\n以前Java项目另外一个痛点就是部署，项目无论大小都需要配置一台服务器(Tomcat等)，然后把项目打包部署上去，所以你还要懂一套服务器部署的内容，可是明明有些项目就很简单啊，非要搞这么复杂，Spring Boot则告诉你，原来Java项目开发也可以很简单，框架内置了一个轻量级的Servlet容器(Tomcat或者Jetty等)，让你很容易地创建一个独立运行项目，只需一个命令，你就可以向运行普通Java程序一样运行一个Java后端程序，是不是很爽！\nSpring Boot主要特点   能够独立运行 Spring Boot创建的程序最终会打成一个jar包，因此，只需要java -jar your-project-name.jar一句命令就可以运行起来了。\n  内置Servlet容器 Spring Boot项目会内置一个容器，如Tomcat、Jetty等，这样我们就不需要再额外配置服务器去部署了。\n  自动装配 从spring最原始的xml配置bean一路走来，曾几何时觉得@Autowired自动装配已经非常好用了，而Spring Boot则可以根据类路径中的jar包、类，为jar包里的类自动装配bean，这样就更进一步地减少了配置的工作量。但是嘛，自动的总会出问题的，它并不能帮你解决任何问题，当你发现它做的不够的时候，还是需要手动地去配置一下，但是相比而言，它也能够应付一部分场景了。\n  摆脱繁杂的XML和代码配置 Spring 4.x里已经可以通过注解来实现配置了，而Spring Boot则把这一特性发挥到了极致，一个项目里你甚至可以不写一行xml，不写一行配置代码，就可以完成。\n  简化的Maven配置 Maven的出现已经可以帮我解决了很多依赖的问题，不用再一个一个jar包去下载导入，但是有没有这么一种感觉，我还是要在pom里面写很多，而且有时候我根本不知道要添加哪个jar包，这一点Spring Boot也想到了，它提供了一系列starter来简化Maven依赖，比如你只需要添加一个spring-boot-starter-web，如下，就可添加web开发中常用的依赖包。\n  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 从哪里开始  https://start.spring.io/ 说了那么多Spring Boot的好处，怎么开始呢？这一点也充分体现了其简单的特点，非常方便。  访问https://start.spring.io/ ，就可以看到Spring Boot官方的项目生成页面，你只需要填写项目的信息，选择一下依赖，然后点击Generate Project就可以生成项目文件并下载zip包。\n在这里可以选择使用Maven管理还是Gradle管理项目依赖，使用Java、Kotlin还是Groovy，还有Spring Boot的版本，打包方式，Java版本，等等，其他的可以自行查看。当然即使生成项目的时候填错了也没关系，后面还可以改嘛。\n手动创建 求人不如求己，有时候你还是需要知道如何手动的去创建一个项目，说到底，所有的生成工具帮你生成还是一个Maven项目，或者Gradle项目，只不过是帮你填写好了一些信息而已，你完全可以自己手动填写。  这里以Maven项目为例：\n 首先你需要新建一个空的Maven项目，这个就不说了，不会的去面壁； 添加Spring Boot父依赖，提供相关的默认依赖，指定版本号，如下；  \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; 添加相关starter 比如这里添加了web支持和security支持：  \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-security\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加编译插件  \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt;\t\u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt;\t\u0026lt;/build\u0026gt;  完成\n  其他方式 除了这两种方式之外还有其他一些方式，比如Spring Boot CLI、Spring Tool Suite等等，这些就不做介绍了。\n  如何开始 这里采用在http://start.spring.io上新建项目后下载，这是下载之后的文件目录：\n. ├── mvnw ├── mvnw.cmd ├── pom.xml └── src ├── main │ ├── java │ │ └── site │ │ └── holten │ │ └── springboot0 │ │ └── Springboot0Application.java │ └── resources │ └── application.properties └── test └── java └── site └── holten └── springboot0 └── Springboot0ApplicationTests.java 12 directories, 6 files 我们首先看一下pom.xml，这里只添加了web starter：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;site.holten\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springboot0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;jar\u0026lt;/packaging\u0026gt; \u0026lt;name\u0026gt;springboot0\u0026lt;/name\u0026gt; \u0026lt;description\u0026gt;Demo project for Spring Boot\u0026lt;/description\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.5.4.RELEASE\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;project.reporting.outputEncoding\u0026gt;UTF-8\u0026lt;/project.reporting.outputEncoding\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 作为简单示例，我们直接在Springboot0Application.java中编写代码：\npackage site.holten.springboot0; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @SpringBootApplication public class Springboot0Application { public static void main(String[] args) { SpringApplication.run(Springboot0Application.class, args); } @RequestMapping(\u0026quot;/\u0026quot;) public String homepage() { return \u0026quot;this is home page!\u0026quot;; } @RequestMapping(\u0026quot;/hello/{name}\u0026quot;) public String sayHello(@PathVariable String name) { return \u0026quot;hello \u0026quot; + name; } } 这里了解这么几点就可以了：\n SpringApplication.run(Springboot0Application.class, args)：main方法中的这句话用来指定程序的入口； @SpringBootApplication：这个是最重要的，标识着这是一个Spring Boot项目，开启自动配置； @RestController：这个是Spring MVC里面的注解，组合了@Controller和@ResponseBody； @RequestMapping：用来映射请求路径/参数、处理类和方法； @Controller：表明这是一个Spring MVC的Controller，Dispatcher Servlet会自动扫描该类，发现其中的@RequestMapping注解并映射； @ResponseBody：用来支持把返回值放到response体内；  代码写完了，如何运行呢？\n 如果你是用的IDE，那么直接run或者debug就可以了； 如果没有，可以在命令行里运行mvn spring-boot:run，当然，前提是你要安装了maven，并且在项目根目录下； 然后在地址栏输入http://localhost:8080/或者http://localhost:8080/hello/yourname就可以看到结果了；  具体效果就不贴图了，自行体会～～～\n","id":15,"section":"posts","summary":"什么是Spring Boot 读研期间主要写的是Java后端，工作之后开始更多地接触Node.js写后端程序，有对比才有伤害，让我深深的感受到了Jav","tags":["Java","Spring Boot"],"title":"Spring Boot那些事(0)-入门篇","uri":"https://holtenko.github.io/blog/2017/07/21/spring-boot-0-intro/","year":"2017"},{"content":"前言 多线程是我们开发过程中经常遇到的，也是必不可少需要掌握的。当我们知道需要进行多线程开发时首先需要知道的自然是如何实现多线程，也就是我们应该如何创建线程。\n在Java中创建线程和创建普通的类的对象操作是一样的，我们可以通过两种方式来创建线程：\n 继承Thread类，并重写run()方法。 实现Runnable接口，并实现run()方法。  方法一：继承Thread类 代码非常简单\n 首先重载一个构造函数，以便我们可以给线程命名。 重写run()方法。 这里我们先让线程输出线程名+start。 然后每5ms输出线程名+一个递增数。  /** * Created by holten.gao on 2016/10/17. */ public class threadThread extends Thread { public threadThread(String name) { super(name); } @Override public void run() { System.out.println(this.getName()+\u0026quot; start!\u0026quot;); for(int i=0;i\u0026lt;10;i++){ System.out.println(this.getName()+\u0026quot; \u0026quot;+i); try { Thread.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } } } } 方法二：实现Runnable接口 代码也非常简单\n 实现run()方法。 这里我们先让线程输出线程名+start。 然后每5ms输出线程名+一个递增数。  /** * Created by holten.gao on 2016/10/17. */ public class runnableThread implements Runnable { @Override public void run() { System.out.println(Thread.currentThread().getName()+\u0026quot; start!\u0026quot;); for(int i=0;i\u0026lt;10;i++){ System.out.println(Thread.currentThread().getName()+\u0026quot; \u0026quot;+i); try { Thread.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); } } } } 测试结果 测试代码\n/** * Created by holten.gao on 2016/10/17. */ public class Main { public static void main(String[] args) { Thread threadThread=new threadThread(\u0026quot;threadThread\u0026quot;); threadThread.start(); Thread runnableThread=new Thread(new runnableThread(),\u0026quot;runnableThread\u0026quot;); runnableThread.start(); } } 测试结果\nthreadThread start! threadThread 0 runnableThread start! runnableThread 0 threadThread 1 runnableThread 1 threadThread 2 runnableThread 2 threadThread 3 runnableThread 3 threadThread 4 runnableThread 4 threadThread 5 runnableThread 5 threadThread 6 runnableThread 6 threadThread 7 runnableThread 7 threadThread 8 runnableThread 8 threadThread 9 runnableThread 9 两种方法比较  因为Java只支持单继承，所以使用方法一就不能再继承其他类了；而方法二实现接口则不会影响继承其他类。 方法一由于是继承Thread，所以直接new出来就可以start；而方法二需要将对象作为参数传入Thread对象才能得到Thread对象。 方法一中可以直接通过this.getName获得线程名；而方法二需要Thread.currentThread().getName()获得  ","id":16,"section":"posts","summary":"前言 多线程是我们开发过程中经常遇到的，也是必不可少需要掌握的。当我们知道需要进行多线程开发时首先需要知道的自然是如何实现多线程，也就是我们应","tags":["Java","线程","Thread"],"title":"Java中创建线程的两种方式","uri":"https://holtenko.github.io/blog/2016/10/17/java-create-threads/","year":"2016"},{"content":"前言 之前写过一篇关于JVM内存区域划分的文章，但是昨天接到蚂蚁金服的面试，问到JVM相关的内容，解释一下JVM的内存区域划分，这部分答得还不错，但是后来又问了Java里面String存放的位置，之前只记得String是一个不变的量，应该是要存放在常量池里面的，但是后来问到new一个String出来应该是放到哪里的，这个应该是放到堆里面的，后来又问到String的引用是放在什么地方的，当时傻逼的说也是放在堆里面的，现在总结一下：基本类型的变量数据和对象的引用都是放在栈里面的，对象本身放在堆里面，显式的String常量放在常量池，String对象放在堆中。\n常量池的说明 常量池之前是放在方法区里面的，也就是在永久代里面的，从JDK7开始移到了堆里面。这一改变我们可以从oracle的release version的notes里的** Important RFEs Addressed in JDK 7 **看到。\nArea: HotSpot Synopsis: In JDK 7, interned strings are no longer allocated in the permanent generation of the Java heap, but are instead allocated in the main part of the Java heap (known as the young and old generations), along with the other objects created by the application. This change will result in more data residing in the main Java heap, and less data in the permanent generation, and thus may require heap sizes to be adjusted. Most applications will see only relatively small differences in heap usage due to this change, but larger applications that load many classes or make heavy use of the String.intern() method will see more significant differences. RFE: 6962931 String内存位置说明 1.显式的String常量\nString a = \u0026quot;holten\u0026quot;; String b = \u0026quot;holten\u0026quot;;  第一句代码执行后就在常量池中创建了一个值为holten的String对象； 第二句执行时，因为常量池中存在holten所以就不再创建新的String对象了。 此时该字符串的引用在虚拟机栈里面。  2.String对象\nString a = new String(\u0026quot;holtenObj\u0026quot;); String b = new String(\u0026quot;holtenObj\u0026quot;);  Class被加载时就在常量池中创建了一个值为holtenObj的String对象，第一句执行时会在堆里创建new String(\u0026ldquo;holtenObj\u0026rdquo;)对象； 第二句执行时，因为常量池中存在holtenObj所以就不再创建新的String对象了，直接在堆里创建new String(\u0026ldquo;holtenObj\u0026rdquo;)对象。  验证一下 /** * Created by holten.gao on 2016/8/16. */ public class Main { public static void main(String[] args){ String str1 = \u0026quot;高小天\u0026quot;; String str2 = \u0026quot;高小天\u0026quot;; System.out.println(str1==str2);//true String str3 = new String(\u0026quot;高大天\u0026quot;); String str4 = new String(\u0026quot;高大天\u0026quot;); System.out.println(str3==str4);//false } } 返回结果：\ntrue false ","id":17,"section":"posts","summary":"前言 之前写过一篇关于JVM内存区域划分的文章，但是昨天接到蚂蚁金服的面试，问到JVM相关的内容，解释一下JVM的内存区域划分，这部分答得还不","tags":["Java","内存","String"],"title":"Java中字符串内存位置浅析","uri":"https://holtenko.github.io/blog/2016/08/16/string-memory/","year":"2016"},{"content":"lombok简介 lombok是暑假来到公司实习的时候发现的一个非常好用的小工具，刚见到的时候就感觉非常惊艳，有一种相见恨晚的感觉，用了一段时间之后感觉的确挺不错，所以特此来推荐一下。\nlombok的官方地址：https://projectlombok.org/\nlombok的Github地址：https://github.com/rzwitserloot/lombok\n那么lombok到底是个什么呢，lombok是一个可以通过简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 Java 代码的工具，简单来说，比如我们新建了一个类，然后在其中写了几个字段，然后通常情况下我们需要手动去建立getter和setter方法啊，构造函数啊之类的，lombok的作用就是为了省去我们手动创建这些代码的麻烦，它能够在我们编译源码的时候自动帮我们生成这些方法。\nlombok能够达到的效果就是在源码中不需要写一些通用的方法，但是在编译生成的字节码文件中会帮我们生成这些方法，这就是lombok的神奇作用。\n虽然有人可能会说IDE里面都自带自动生成这些方法的功能，但是使用lombok会使你的代码看起来更加简洁，写起来也更加方便。\nlombok安装 lombok的安装跟一般引用jar包没有什么区别，可以到官网上下载最新的jar包，然后导入到项目里面就好啦。\nMaven添加依赖\n\u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.16.10\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Intellij idea开发的话需要安装Lombok plugin，同时设置 Setting -\u0026gt; Compiler -\u0026gt; Annotation Processors -\u0026gt; Enable annotation processing勾选。\nlombok使用 lombok使用过程中主要是靠注解起作用的，官网上的文档里面有所有的注解，这里不一一罗列，只说明其中几个比较常用的。\n@NonNull: 可以帮助我们避免空指针。 使用lombok：\nimport lombok.NonNull; public class NonNullExample extends Something { private String name; public NonNullExample(@NonNull Person person) { super(\u0026quot;Hello\u0026quot;); this.name = person.getName(); } } 不使用lombok：\npublic class NonNullExample extends Something { private String name; public NonNullExample(@NonNull Person person) { super(\u0026quot;Hello\u0026quot;); if (person == null) { throw new NullPointerException(\u0026quot;person\u0026quot;); } this.name = person.getName(); } } @Cleanup: 自动帮我们调用close()方法。 使用lombok：\nimport lombok.Cleanup; import java.io.*; public class CleanupExample { public static void main(String[] args) throws IOException { @Cleanup InputStream in = new FileInputStream(args[0]); @Cleanup OutputStream out = new FileOutputStream(args[1]); byte[] b = new byte[10000]; while (true) { int r = in.read(b); if (r == -1) break; out.write(b, 0, r); } } } 不使用lombok：\nimport java.io.*; public class CleanupExample { public static void main(String[] args) throws IOException { InputStream in = new FileInputStream(args[0]); try { OutputStream out = new FileOutputStream(args[1]); try { byte[] b = new byte[10000]; while (true) { int r = in.read(b); if (r == -1) break; out.write(b, 0, r); } } finally { if (out != null) { out.close(); } } } finally { if (in != null) { in.close(); } } } } @Getter / @Setter: 自动生成Getter/Setter方法 使用lombok：\nimport lombok.AccessLevel; import lombok.Getter; import lombok.Setter; public class GetterSetterExample { @Getter @Setter private int age = 10; @Setter(AccessLevel.PROTECTED) private String name; } 不使用lombok：\npublic class GetterSetterExample { private int age = 10; private String name; public int getAge() { return age; } public void setAge(int age) { this.age = age; } protected void setName(String name) { this.name = name; } } @NoArgsConstructor: 自动生成无参数构造函数。 @AllArgsConstructor: 自动生成全参数构造函数。 @Data: 自动为所有字段添加@ToString, @EqualsAndHashCode, @Getter方法，为非final字段添加@Setter,和@RequiredArgsConstructor! 还有其他一些比如自动生成日志对象等等之类的注解可以到官方网站去了解，就不一一列举了。\n官方文档https://projectlombok.org/features/index.html\n","id":18,"section":"posts","summary":"lombok简介 lombok是暑假来到公司实习的时候发现的一个非常好用的小工具，刚见到的时候就感觉非常惊艳，有一种相见恨晚的感觉，用了一段时","tags":["Java","Plugin"],"title":"Lombok介绍及使用方法","uri":"https://holtenko.github.io/blog/2016/08/02/lombok-introduction/","year":"2016"},{"content":"算法简介 冒泡排序是一种最基础也是最简单的排序算法，它是一种稳定排序算法，其平均时间复杂度为$O(n^2)$，空间复杂度为$O(1)$，是一种原地排序算法。\n算法原理(从后往前冒泡) 冒泡排序的思想其实很简单，就是从最后一个元素开始，依次与其前面的元素作比较，如果位置错误就交换位置，否则不采取操作，一直到第一个元素，此时第一个元素一定是最大(最小)的元素；然后重复上述操作一直到第二个元素；然后一直对越来越少的元素进行比较和交换位置；直到所有元素都不再需要比较，排序完成。\n算法实现(Java) 该示例为从小到大排序\npublic void BubbleSort(int[] a) { for (int i = 0; i \u0026lt; a.length; i++) { for (int j = a.length - 1; j \u0026gt; i; j--) { if (a[j] \u0026lt; a[j - 1]) exch(a, j, j - 1); } } } 排序过程及结果 Origin: 2 1 6 4 9 5 3 1 7 8 Process: 2 1 6 4 9 5 1 3 7 8 2 1 6 4 9 1 5 3 7 8 2 1 6 4 1 9 5 3 7 8 2 1 6 1 4 9 5 3 7 8 2 1 1 6 4 9 5 3 7 8 1 2 1 6 4 9 5 3 7 8 1 2 1 6 4 9 3 5 7 8 1 2 1 6 4 3 9 5 7 8 1 2 1 6 3 4 9 5 7 8 1 2 1 3 6 4 9 5 7 8 1 1 2 3 6 4 9 5 7 8 1 1 2 3 6 4 5 9 7 8 1 1 2 3 4 6 5 9 7 8 1 1 2 3 4 6 5 7 9 8 1 1 2 3 4 5 6 7 9 8 1 1 2 3 4 5 6 7 8 9 Result: 1 1 2 3 4 5 6 7 8 9 ","id":19,"section":"posts","summary":"算法简介 冒泡排序是一种最基础也是最简单的排序算法，它是一种稳定排序算法，其平均时间复杂度为$O(n^2)$，空间复杂度为$O(1)$，是一种","tags":["排序","算法"],"title":"排序算法之冒泡排序","uri":"https://holtenko.github.io/blog/2016/05/08/bubble-sort/","year":"2016"},{"content":"自动垃圾回收是Java相较于C++的一个重要的特点，想了解JVM的垃圾回收机制，首先我们要知道垃圾回收是回收什么地方的垃圾，我在我的上一篇博客《JVM内存区域划分》里面有写到JVM里面的内存是怎么分布的，这里的回收主要是指对上文中提到的Java堆和方法区的内存的回收。\n什么样的对象可以被回收 知道了回收哪里的内存之后，我们还需要知道什么样的对象是可以被回收，或者说是需要被回收的，这些对象我们称之为死掉的对象。那么哪些对象是死掉了的呢？我们说当一个对象不存在任何引用的时候就可以说这个对象是死掉了。\n那么什么时候这个对象不存在任何引用了呢？\n有一些地方说，可以使用引用计数算法来判断对象是否还存活，引用计数算法是说给对象添加一个引用计数器，每当一个地方引用它时就加1，引用失效时就减1，计数器的值变为0就说这个对象不存在任何引用了，但是这样会存在一个很严重的问题，就是循环引用的问题。比如如下的例子：\npublic class Example{ public Object instance = null; public static void test(){ Example objA=new Example(); Example objB=new Example(); objA.instance=objB; objB.instance=objA; objA=null; objB=null; } } 这样的话，objA和objB的引用计数都不为0，但是他们的确是不会再被使用的了。\n那么Java里面是用什么样的算法来实现对引用的判断的呢？\nJava里是使用可达性分析的方法来实现的。\n如图所示，就是通过一系列的称为\u0026quot;GC Roots\u0026quot;的对象作为起始点，从这些点向下搜索，搜索的路径称为引用链，当一个对象到达GC Roots没有任何引用链时，就可以证明这个对象是不可用的。那么这个对象就可以被回收了。像图中的Obj1-5都属于存活的对象，但是Obj6-8虽然还存在相互引用，但是已经是可以认为是死掉的对象了。\n引用 目前来说，Java中的引用可以分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)四种，他们的引用顺序依次逐渐减弱。\n 强引用是用来描述必须存在和引用的对象，比如Object a=new Object()，只要强引用还存在，被引用的对象就永远不会被回收。 软引用是用来描述一些还有用但是不是必需的对象。这类引用的对象会在内存溢出之前被列入回收范围进行第二次回收，如若回收完之后还没有获得足够的内存才会抛出内存溢出异常。可以使用SoftReference类来实现。 弱引用是用来描述非必需的对象，但是强度比软引用更弱，被引用的对象只能存活到下一次GC之前。当进行GC的时候不论内存是否足够都会对该引用的对象进行回收。可以使用WeakReference类来实现。 虚引用是最弱的引用关系。虚引用的存在不会对对象的存活造成任何影响，也不能通过虚引用来获得任何对象实例。设置虚引用的唯一目的就是在关联对象被回收时会获得一个系统通知。可以使用PhantomReference类来实现。  死亡对象的自我救赎 当一个对象在进行可达性分析的时候发现已经是没有任何引用的了，这时候垃圾收集器并没有立即判处该对象死刑，而是给了它一次自我救赎的机会，这时它会被标记一次，同时判断是不是有必要执行finalize()方法，当对象没有重写finalize()方法或者finalize()方法已经被执行过的时候，就不执行finalize()方法。下面就会有两种情况发生了：\n 执行finalize()方法：这时这个对象会被放在F-Queue队列之中，然后由虚拟机自动创建一个低优先级的Finalizer线程去执行它，但是为了保证F-Queue不被无限阻塞并不保证一定会等待它执行结束。此时在finalize()里如果对象又重新获得与GC Roots的联系就可以完成自我救赎，否则的话就只能被第二次标记，然后听天由命了。 不执行finalize()方法：这时候要么是垃圾收集器已经给过一次机会了，要么是对象自己没有重写finalize()去获得机会，这个时候就只能被第二次标记，立即被执行死刑了。  方法区的回收 方法区的回收分为废弃常量的回收和无用类的卸载。\n 废弃常量的回收：回收废弃常量与上面所说的堆中对象的回收差不多，没有任何引用的时候回收。 无用类的卸载：类的卸载需要满足三个条件：   该类的所有对象都被回收。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class没有在任何地方被引用，无法在任何地方通过反射访问该类。 但是满足这三个条件只是说可以被回收，但是不代表一定被回收，具体是否被回收还要由虚拟机里的一些参数来具体确定。  ","id":20,"section":"posts","summary":"自动垃圾回收是Java相较于C++的一个重要的特点，想了解JVM的垃圾回收机制，首先我们要知道垃圾回收是回收什么地方的垃圾，我在我的上一篇博","tags":["Java","JVM","内存"],"title":"JVM内存回收对象及引用分析","uri":"https://holtenko.github.io/blog/2016/04/21/jvm-gc-object-reference/","year":"2016"},{"content":"学习Java不可避免的要学习Java虚拟机，也就是JVM，Java虚拟机规范里面规定了程序运行期间会使用到的运行时数据区，这也是JVM的内存区域划分的模型，应该可以这么理解吧。\n这其中有一些是随着虚拟机的启动和退出而创建和销毁的，这些区域是线程共享的，另外有一些是跟各个线程绑定的，随着线程的开始和结束而创建和销毁，我们可以称这些区域是线程私有的。\n根据《Java虚拟机规范Java SE 7版》和《Java虚拟机规范Java SE 8版》的规定，我们可以划分出如下几个运行时数据区，如下图所示： Java堆 在Java虚拟机中，堆是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。这块区域随着虚拟机的启动而创建，它的唯一使命就是存放对象实例，这块区域也是GC主要关注的地方。\n下面的就是我的笔记本上的JVM堆的划分情况，可以看到分为新生代、老年代和永久代，新生代里面有可以分为Eden Space、From Survivor Space和To Survivor Space。\nHeap Usage: PS Young Generation Eden Space: capacity = 17301504 (16.5MB) used = 2483088 (2.3680572509765625MB) free = 14818416 (14.131942749023438MB) 14.351862127130682% used From Space: capacity = 2621440 (2.5MB) used = 2615312 (2.4941558837890625MB) free = 6128 (0.0058441162109375MB) 99.7662353515625% used To Space: capacity = 6291456 (6.0MB) used = 0 (0.0MB) free = 6291456 (6.0MB) 0.0% used PS Old Generation capacity = 44564480 (42.5MB) used = 13316368 (12.699478149414062MB) free = 31248112 (29.800521850585938MB) 29.88112505744485% used PS Perm Generation capacity = 22020096 (21.0MB) used = 14907008 (14.2164306640625MB) free = 7113088 (6.7835693359375MB) 67.6972888764881% used 根据虚拟机规范的规定，Java堆可以是固定的大小也可以是按照需求动态扩展的，而且不需要保证是连续的。\n**存放内容：**所有的对象实例和数组。\n方法区 方法区是一个线程共享的区域，它用于存储已被虚拟机加载的类信息、常量、静态变量。方法区是堆的逻辑组成部分，Hotspot用永久代实现了方法区。 方法区还包含运行时常量池(JDK1.7以后移到堆中)，用于存放编译时生成的各种字面量和符号引用，但是不要求常量一定是在编译时期产生的，运行期间也可以将新的常量放入池中，比如String的intern()方法便是利用了这一特性。\n**存放内容：**类的结构信息，如类的字段、方法、接口、构造函数，还有运行时常量池等。\n程序计数寄存器 这块区域是每个线程独立拥有的，也就是线程私有的，我们可以把它看作是当前线程所执行的字节码的行号指示器。\n这块区域时虚拟机规范里面唯一一个没有规定任何OutOfMemoryError情况的区域。\n**存放内容：**如果线程执行的是一个Java方法，那么寄存器里面记录的就是正在执行的虚拟机字节码指令的地址，如果线程执行的是一个native方法，那么寄存器记录的值为undefined。\n虚拟机栈 虚拟机栈也是线程私有的内存区域。每个方法在执行的时候都会创建一个栈帧用于存储局部变量表、操作数栈、方法出口等信息，每一个方法从调用到执行完成就是一个栈帧入栈和出栈的过程。\n局部变量表存放了编译时期可知的各种基本数据类型、对象引用和指向了一条字节码指令的地址。\n**存放内容：**局部变量表、操作数栈、方法出口等信息。\n本地方法栈 和虚拟机栈类似，存储Native方法的相关信息。 **存放内容：**局部变量表、操作数栈、方法出口等信息。\n","id":21,"section":"posts","summary":"学习Java不可避免的要学习Java虚拟机，也就是JVM，Java虚拟机规范里面规定了程序运行期间会使用到的运行时数据区，这也是JVM的内存","tags":["Java","JVM","内存"],"title":"JVM内存区域划分","uri":"https://holtenko.github.io/blog/2016/04/09/jvm-memory-area/","year":"2016"},{"content":"终于在某东做活动新入手了一台air，看身边小伙伴的mac的终端感觉好炫酷，于是乎准备自己也捯饬捯饬，google了一下，发现了osx平台上的终端神器iTerm2和用来代替bash的oh-my-zsh，试了一下发现是真的好使，谁用谁知道。\n安装iTerm2  首先你得先下载一个iTerm2。 怎么在osx上安装不用说了，直接copy。 安装完成。  安装oh-my-zsh 直接在iTerm2里面输入： sh -c \u0026quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\u0026quot;即可。\n 注意啦，执行之前记得先装好git。\n 到这里其实已经安装完成了，下面是个性化定制的内容 安装Powerline 直接在iTerm2里面输入：\nsudo easy_install pip pip install powerline-status 安装完成。\n安装字体库 下载下来之后在终端里执行字体库目录下面的install.sh安装powerline字体。\n设置iTerm 2的字体 安装完字体库之后，把iTerm 2的偏好设置里的Profile选项卡下面的Text选项卡中里的Regular Font和Non-ASCII Font的字体都设置成 Powerline的字体，喜欢哪个自己选就好了，后面带for powerline的就行。\n安装配色方案  下载下来之后解压，然后到目录下双击Solarized Dark.itermcolors和Solarized Light.itermcolors两个文件就可以把配置文件导入到iTerm 2里。 通过load presets选择刚刚安装的配色主题即可。   安装agnoster主题  下载下来之后解压，然后到目录里面运行install文件，就可以主题安装到~/.oh-my-zsh/themes目录下 2）cd切换到用户根目录，打开.zshrc文件，然后将ZSH_THEME后面的字段改为agnoster即可。像这样ZSH_THEME=\u0026quot;agnoster\u0026rdquo;。  终于搞完了！ ","id":22,"section":"posts","summary":"终于在某东做活动新入手了一台air，看身边小伙伴的mac的终端感觉好炫酷，于是乎准备自己也捯饬捯饬，google了一下，发现了osx平台上的","tags":["Shell","Install"],"title":"iTerm2和oh-my-zsh的个性化定制","uri":"https://holtenko.github.io/blog/2016/03/17/iterm2-with-ohmyzsh/","year":"2016"},{"content":"最近在做传感器数据采集的工作，底层是基于Zigbee的无线传感网络，所有数据采集到Zigbee协调器上然后通知上位机数据采集完成，上位机通过USB转串口去读取数据就可以了。那么问题来了，如何进行串口通讯呢？老板说你用Java写个程序好了嘛，用Java写串口程序也是醉了。实验室也没别人写了，所以就让我写了。当我听到要让我用Java写串口通讯程序的时候我本来是拒绝的，然后。。。就没有然后了。。就只能写了。\n网上看了一下，最后用了一个开源的Java串口通讯库RXTX做串口通讯，下面记录一下RXTX的使用方法。\n环境配置 RXTX做串口通讯，有一个jar包(RXTXcomm.jar)和一个rxtxSerial.dll(Windows环境下)或者librxtxSerial.so（Linux环境下），因为开发是在Windows上，但是工作是在Linux上，所以两个都用到了。\nWindows环境下\n文档里是这么写的\n Copy rxtxSerial.dll \u0026mdash;\u0026gt; \u0026lt;JAVA_HOME\u0026gt;\\jre\\bin\n 但是这个做了之后并不能用，会有一些很奇怪的问题，不知道是不是我的Java环境配置有问题还是怎么了，我是把dll文件copy到了C:\\Windows\\System32，然后一切正常，一直很奇怪，为什么要cp到\u0026lt;JAVA_HOME\u0026gt;\\jre\\bin呢？求解答！\nLinux环境下\n Copy librxtxSerial.so \u0026mdash;\u0026gt; \u0026lt;JAVA_HOME\u0026gt;/jre/lib/i386/ or Copy librxtxSerial.so \u0026mdash;\u0026gt; \u0026lt;JAVA_HOME\u0026gt;/jre/lib/x86_64/\n 这个按照文档没问题。\n小问题\n我用的是rxtx-2.2pre2版本的，文档里有写运行时会报版本不匹配的WARNING，实际使用中的确也是这样的，不过目前还没有别的问题，不影响使用。\n常用方法 1.查找端口\n/**\r* 查找所有可用端口\r*\r* @return 所有端口列表\r*/\rpublic static final ArrayList\u0026lt;String\u0026gt; findPort() {\rEnumeration\u0026lt;CommPortIdentifier\u0026gt; portList = CommPortIdentifier.getPortIdentifiers();//获得所有串口\rArrayList\u0026lt;String\u0026gt; portNameList = new ArrayList\u0026lt;\u0026gt;();\r//串口名字添加到List并返回\rwhile (portList.hasMoreElements()) {\rString portName = portList.nextElement().getName();\rportNameList.add(portName);\r}\rreturn portNameList;\r}\r2.打开端口\n/**\r* 打开串口\r*\r* @param portName 端口名称\r* @param baudrate 波特率\r* @return 串口对象\r*/\rpublic static final SerialPort openPort(String portName, int baudrate) {\rtry {\r//通过端口名识别端口\rCommPortIdentifier portIdentifier = CommPortIdentifier.getPortIdentifier(portName);\r//打开端口，并给端口名字和一个timeout\rCommPort commPort = portIdentifier.open(portName, 2000);\r//判断是不是串口\rif (commPort instanceof SerialPort) {\rSerialPort serialPort = (SerialPort) commPort;\rtry {\r//设置一下串口的波特率等参数\rserialPort.setSerialPortParams(baudrate, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\r} catch (UnsupportedCommOperationException e) {\rLOGGER.error(\u0026quot;Set Serialport Parameters failure\u0026quot;, e);\r}\rSystem.out.println(\u0026quot;Open \u0026quot; + portName + \u0026quot; sucessfully !\u0026quot;);\rreturn serialPort;\r} else {\rLOGGER.error(\u0026quot;This port is not a serialport\u0026quot;);\rreturn null;\r}\r} catch (NoSuchPortException | PortInUseException e) {\rLOGGER.error(\u0026quot;There is no \u0026quot; + portName + \u0026quot;or it's occupied!\u0026quot;, e);\rreturn null;\r}\r}\r3.发送数据\n/**\r* 发送数据\r*\r* @param serialPort 串口对象\r* @param order 命令字节\r*/\rpublic void sendToPort(SerialPort serialPort, byte[] order) {\rtry {\rOutputStream out = serialPort.getOutputStream();\rout.write(order);\rout.flush();\rout.close();\r} catch (IOException e) {\rLOGGER.error(\u0026quot;Send to SerialPort failure\u0026quot;, e);\r}\r}\r4.读取数据\n/**\r* 读取数据\r*\r* @return 字节ArrayList\r*/\rpublic byte[] readFromPort(InputStream inStream) {\rbyte[] bytes = null;\rtry {\rwhile (true) {\r//获取buffer里的数据长度\rint bufflenth = inStream.available();\rif (0 == bufflenth) {\rbreak;\r}\rbytes = new byte[bufflenth];\rinStream.read(bytes);\r}\r} catch (IOException e) {\rLOGGER.error(\u0026quot;Read Data Failure\u0026quot;, e);\r}\rreturn bytes;\r}\r监听器 1.实现监听器\n继承SerialPortEventListener然后重写serialEvent,然后再各个对应case里面写代码就好啦。\npublic class TestExample implements SerialPortEventListener {\r@Override\rpublic void serialEvent(SerialPortEvent serialPortEvent) {\rswitch (serialPortEvent.getEventType()) {\rcase SerialPortEvent.BI: // 10通讯中断\rcase SerialPortEvent.OE: // 7溢位错误\rcase SerialPortEvent.FE: // 9帧错误\rcase SerialPortEvent.PE: // 8奇偶校验错\rcase SerialPortEvent.CD: // 6载波检测\rcase SerialPortEvent.CTS: // 3清除发送\rcase SerialPortEvent.DSR: // 4数据设备准备好\rcase SerialPortEvent.RI: // 5振铃指示\rcase SerialPortEvent.OUTPUT_BUFFER_EMPTY: // 2输出缓冲区已清空\rcase SerialPortEvent.DATA_AVAILABLE: // 1读到可用数据时激活\r}\r}\r}\r2.给串口添加监听器\n/**\r* 添加监听器\r*\r* @param port 串口对象\r* @param listener 串口监听器\r*/\rpublic static void addListener(SerialPort port, SerialPortEventListener listener) {\rtry {\r// 给串口添加监听器\rport.addEventListener(listener);\r// 设置当有数据到达时唤醒监听接收线程\rport.notifyOnDataAvailable(true);\rport.notifyOnBreakInterrupt(true);\rSystem.out.println(\u0026quot;Add listeners to \u0026quot; + port.getName() + \u0026quot; sucessfully !\u0026quot;);\r} catch (TooManyListenersException e) {\rLOGGER.error(\u0026quot;There is too many listeners !\u0026quot;, e);\r}\r}\rTIP ** 一定记得从串口发指令取数据之后加一个延时，等待底层数据传输完成再去buffer里面取，不然很大可能数据包不完整。 **\n","id":23,"section":"posts","summary":"最近在做传感器数据采集的工作，底层是基于Zigbee的无线传感网络，所有数据采集到Zigbee协调器上然后通知上位机数据采集完成，上位机通过","tags":["Java","Library","Rxtx"],"title":"Java利用Rxtx进行串口通讯","uri":"https://holtenko.github.io/blog/2015/12/05/rxtx-comm/","year":"2015"},{"content":"下载源码 到Git的Github主页上下载最新的源码到本地，解压并进入目录。\n编译安装 cd 你的git源码目录\rautoconf\r./configure\rmake\r第一个报错 报错内容：\nusr/bin/perl Makefile.PL PREFIX='/usr/local/git' INSTALL_BASE='' --localedir='/usr/local/git/share/locale'\rCan't locate ExtUtils/MakeMaker.pm in @INC (@INC contains: /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at Makefile.PL line 3.\rBEGIN failed--compilation aborted at Makefile.PL line 3.\rmake[1]: *** [perl.mak] Error 2\rmake: *** [perl/perl.mak] Error 2\r解决方法：\nyum install perl-ExtUtils-MakeMaker package\r第二个报错 报错内容：\ntclsh failed; using unoptimized loading\rMSGFMT po/bg.msg make[1]: *** [po/bg.msg] 错误 127\r解决方法：\nyum install tcl build-essential tk gettext\r继续编译安装 make\rmake install\r终于世界清净了\n建立软链接 ln -s /usr/local/bin/git /usr/bin\rgit --version\r出现了\ngit version 2.6.0.GIT\r至此，安装完成。\n","id":24,"section":"posts","summary":"下载源码 到Git的Github主页上下载最新的源码到本地，解压并进入目录。 编译安装 cd 你的git源码目录 autoconf ./configure make 第一个报错 报错内容： usr/bin/perl Makefile.PL PREFIX='/usr/local/git' INSTALL_BASE='' --localedir='/usr/local/git/share/locale' Can't","tags":["Git","Install"],"title":"CentOS下通过源码安装最新版Git","uri":"https://holtenko.github.io/blog/2015/12/05/git-install-with-source/","year":"2015"},{"content":"jdk下载 这个到java的官方网站下载自己需要的版本就好了，这里下载了jdk1.7版本的，选择下载了rpm包jdk-7u79-linux-x64.rpm。 rpm安装 rpm -ivh jdk安装包的目录/jdk-7u79-linux-x64.rpm\r解释一下： -i,\u0026ndash;install 表示安装软件包 install package(s) -v,\u0026ndash;verbose 表示安装过程中输出软件包更多的信息 provide more detailed output -h,\u0026ndash;hash 表示显示安装进度 print hash marks as package installs (good with -v) 配置环境变量 vim /etc/profile\r在最后添加\nexport JAVA_HOME=/usr/java/jdk1.7.0_79\rexport JRE_HOME=$JAVA_HOME/jre\rexport PATH=$PATH:$JAVA_HOME/bin\rexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib\r保存文件，然后执行以下命令使配置文件生效即可。\nsource /etc/profile\r最后测试一下\n# java -version\rjava version \u0026quot;1.7.0_79\u0026quot;\rJava(TM) SE Runtime Environment (build 1.7.0_79-b15)\rJava HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)\r至此，安装完成！\n","id":25,"section":"posts","summary":"jdk下载 这个到java的官方网站下载自己需要的版本就好了，这里下载了jdk1.7版本的，选择下载了rpm包jdk-7u79-linux-x","tags":["Java","JDK","Install"],"title":"Linux环境下RPM方式JDK安装及配置","uri":"https://holtenko.github.io/blog/2015/11/25/jdk-install/","year":"2015"}],"tags":[{"title":"Error","uri":"https://holtenko.github.io/blog/tags/error/"},{"title":"FTP","uri":"https://holtenko.github.io/blog/tags/ftp/"},{"title":"Git","uri":"https://holtenko.github.io/blog/tags/git/"},{"title":"Install","uri":"https://holtenko.github.io/blog/tags/install/"},{"title":"Java","uri":"https://holtenko.github.io/blog/tags/java/"},{"title":"JDK","uri":"https://holtenko.github.io/blog/tags/jdk/"},{"title":"JVM","uri":"https://holtenko.github.io/blog/tags/jvm/"},{"title":"Library","uri":"https://holtenko.github.io/blog/tags/library/"},{"title":"Linux","uri":"https://holtenko.github.io/blog/tags/linux/"},{"title":"Mac","uri":"https://holtenko.github.io/blog/tags/mac/"},{"title":"Markdown","uri":"https://holtenko.github.io/blog/tags/markdown/"},{"title":"Plugin","uri":"https://holtenko.github.io/blog/tags/plugin/"},{"title":"Raspberry","uri":"https://holtenko.github.io/blog/tags/raspberry/"},{"title":"Rxtx","uri":"https://holtenko.github.io/blog/tags/rxtx/"},{"title":"Shell","uri":"https://holtenko.github.io/blog/tags/shell/"},{"title":"Spring","uri":"https://holtenko.github.io/blog/tags/spring/"},{"title":"Spring Boot","uri":"https://holtenko.github.io/blog/tags/spring-boot/"},{"title":"String","uri":"https://holtenko.github.io/blog/tags/string/"},{"title":"Thread","uri":"https://holtenko.github.io/blog/tags/thread/"},{"title":"Tomcat","uri":"https://holtenko.github.io/blog/tags/tomcat/"},{"title":"Tools","uri":"https://holtenko.github.io/blog/tags/tools/"},{"title":"Wiki","uri":"https://holtenko.github.io/blog/tags/wiki/"},{"title":"内存","uri":"https://holtenko.github.io/blog/tags/%E5%86%85%E5%AD%98/"},{"title":"抽象工厂模式","uri":"https://holtenko.github.io/blog/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"title":"排序","uri":"https://holtenko.github.io/blog/tags/%E6%8E%92%E5%BA%8F/"},{"title":"算法","uri":"https://holtenko.github.io/blog/tags/%E7%AE%97%E6%B3%95/"},{"title":"线程","uri":"https://holtenko.github.io/blog/tags/%E7%BA%BF%E7%A8%8B/"},{"title":"设计模式","uri":"https://holtenko.github.io/blog/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}