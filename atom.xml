<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小天涯</title>
  
  <subtitle>Make your own way.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.holten.com/"/>
  <updated>2019-08-22T12:00:21.699Z</updated>
  <id>http://blog.holten.com/</id>
  
  <author>
    <name>Holten</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>没事学点设计模式-单例模式</title>
    <link href="http://blog.holten.com/2018/03/22/design-pattern-4/"/>
    <id>http://blog.holten.com/2018/03/22/design-pattern-4/</id>
    <published>2018-03-22T06:37:45.000Z</published>
    <updated>2019-08-22T12:00:21.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系列回顾"><a href="#系列回顾" class="headerlink" title="系列回顾"></a>系列回顾</h3><ol><li><a href="http://blog.holten.site/2017/09/11/design-pattern-1/" target="_blank" rel="noopener">没事学点设计模式-概览</a></li><li><a href="http://blog.holten.site/2017/09/29/design-pattern-2/" target="_blank" rel="noopener">没事学点设计模式-工厂模式</a></li><li><a href="http://blog.holten.site/2018/02/12/design-pattern-3/" target="_blank" rel="noopener">没事学点设计模式-抽象工厂模式</a></li></ol><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>单例模式（Singleton Pattern）可以说是Java中最简单的设计模式。这种类型的设计模式属于创建型模式，它提供了一种创建一个全局唯一对象的最佳方式，可以避免一个全局使用的对象，尤其是大对象，的频繁创建与销毁。</p><p>这种模式涉及到一个单一的类，该类负责创建自己的对象实例，同时确保只有一个对象实例被创建。这个类提供了访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。这就意味着单例类只能有一个实例，而且必须自己给自己创建唯一的实例，同时必须给其他所有对象提供这一实例。<br><a id="more"></a><br><strong>优点</strong></p><ol><li>在单例模式中，对单例类的所有实例化得到的都是相同的一个实例，可以确保所有的对象都访问同一个实例。</li><li>类自己来控制实例化进程，类就在改变实例化进程上有相应的伸缩性。</li><li>提供了对唯一实例的受控访问。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，当需要频繁创建和销毁的对象，特别是大对象时可以提高系统的性能。</li><li>避免对共享资源的多重占用。</li></ol><p><strong>缺点</strong></p><ol><li>无法继承，扩展比较困难。</li><li>不适用于变化的对象。</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>单例模式的实现有非常多，但是有些是线程安全的，有些是线程不安全的，这里仅介绍几种线程安全的实现方法。</p><h4 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h4><p>这种方式可以实现懒加载，线程安全，但是会存在效率问题，因为绝大多数情况下是不需要同步加锁的。</p><p><strong>代码如下：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h4><p>这种方式基于classloader机制避免了线程安全问题，但是实例在类加载时就实例化了，可能会产生垃圾对象。</p><p><strong>代码如下：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="双重校验式"><a href="#双重校验式" class="headerlink" title="双重校验式"></a>双重校验式</h4><p>这种方式采用双重校验锁的机制，可以保证线程安全且可以保证较好的性能。</p><p><strong>代码如下：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h4><p>这种方式和饿汉式采用相同的机制来保证线程安全，但是通过静态内部类的形式实现了懒加载，避免了垃圾对象的产生。</p><p><strong>代码如下：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="枚举式"><a href="#枚举式" class="headerlink" title="枚举式"></a>枚举式</h4><p>这种方式在实际使用中很少被采用，但是这确实是目前实现单例最好的方式，简洁，自动支持序列化机制，绝对防止多次实例化，也无法通过反射调用构造函数的方式来创建实例。</p><p><strong>代码如下：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;  </span><br><span class="line">    INSTANCE;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">yourMethod</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="本文源码已托管至GitHub，欢迎Star"><a href="#本文源码已托管至GitHub，欢迎Star" class="headerlink" title="本文源码已托管至GitHub，欢迎Star"></a>本文源码已托管至GitHub，欢迎Star</h3><p><a href="https://github.com/holtenko/DesignPatterns/tree/master/src/Singleton" target="_blank" rel="noopener">抽象工厂模式源码：https://github.com/holtenko/DesignPatterns/tree/master/src/Singleton</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;系列回顾&quot;&gt;&lt;a href=&quot;#系列回顾&quot; class=&quot;headerlink&quot; title=&quot;系列回顾&quot;&gt;&lt;/a&gt;系列回顾&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.holten.site/2017/09/11/design-pattern-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;没事学点设计模式-概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.holten.site/2017/09/29/design-pattern-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;没事学点设计模式-工厂模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.holten.site/2018/02/12/design-pattern-3/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;没事学点设计模式-抽象工厂模式&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;单例模式（Singleton Pattern）可以说是Java中最简单的设计模式。这种类型的设计模式属于创建型模式，它提供了一种创建一个全局唯一对象的最佳方式，可以避免一个全局使用的对象，尤其是大对象，的频繁创建与销毁。&lt;/p&gt;
&lt;p&gt;这种模式涉及到一个单一的类，该类负责创建自己的对象实例，同时确保只有一个对象实例被创建。这个类提供了访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。这就意味着单例类只能有一个实例，而且必须自己给自己创建唯一的实例，同时必须给其他所有对象提供这一实例。&lt;br&gt;
    
    </summary>
    
      <category term="Basic" scheme="http://blog.holten.com/categories/Basic/"/>
    
    
      <category term="设计模式" scheme="http://blog.holten.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>没事学点设计模式-抽象工厂模式</title>
    <link href="http://blog.holten.com/2018/02/12/design-pattern-3/"/>
    <id>http://blog.holten.com/2018/02/12/design-pattern-3/</id>
    <published>2018-02-12T05:56:14.000Z</published>
    <updated>2019-08-22T12:00:21.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系列回顾"><a href="#系列回顾" class="headerlink" title="系列回顾"></a>系列回顾</h3><ol><li><a href="http://blog.holten.site/2017/09/11/design-pattern-1/" target="_blank" rel="noopener">没事学点设计模式-概览</a></li><li><a href="http://blog.holten.site/2017/09/29/design-pattern-2/" target="_blank" rel="noopener">没事学点设计模式-工厂模式</a></li></ol><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。<br><a id="more"></a><br><strong>举例说明</strong><br>iPhone 8和iPhone X的屏幕和外壳都是不一样的，通过抽象工厂模式就可以实现，在为iPhone生产配件的时候不用指定相关的型号，可以自动根据手机的型号生产相应的配件。</p><p><strong>优点</strong><br>当一个系列中的多个对象被设计成一起工作时，它能保证调用时始终只使用同一个系列中的对象，而不需要去指定具体的型号。</p><p><strong>缺点</strong><br>系列扩展非常困难，要增加一个系列的某一产品时，既要在抽象的 Factory 里加代码，又要在具体的实现里面加代码。比如后面发现iPhone X配AirPods，iPhone 8配EarPods，那么不仅要Factory接口中添加方法，还要在其实现类中去修改。</p><p><strong>使用场景</strong></p><ol><li>软件的更换界面主题功能；</li><li>生成不同操作系统的软件；</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>1.首先需要创建一个Screen、Shell接口和其实现类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Screen8</span> <span class="keyword">implements</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"iphone 8 screen get!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenX</span> <span class="keyword">implements</span> <span class="title">Screen</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"iphone X screen get!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Shell8</span> <span class="keyword">implements</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"iphone 8 shell get!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellX</span> <span class="keyword">implements</span> <span class="title">Shell</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"iphone X shell get!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.然后定义抽象工厂接口IphoneFactory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IphoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Screen <span class="title">getScreen</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Shell <span class="title">getShell</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.实现相应的工厂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone8Factory</span> <span class="keyword">implements</span> <span class="title">IphoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Screen <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Screen8();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shell <span class="title">getShell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Shell8();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IphoneXFactory</span> <span class="keyword">implements</span> <span class="title">IphoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Screen <span class="title">getScreen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScreenX();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Shell <span class="title">getShell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShellX();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>4.可以生产了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IphoneFactory factory = <span class="keyword">new</span> IphoneXFactory();</span><br><span class="line">        Screen screen = factory.getScreen();</span><br><span class="line">        Shell shell = factory.getShell();</span><br><span class="line">        screen.build();</span><br><span class="line">        shell.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="本文源码已托管至GitHub，欢迎Star"><a href="#本文源码已托管至GitHub，欢迎Star" class="headerlink" title="本文源码已托管至GitHub，欢迎Star"></a>本文源码已托管至GitHub，欢迎Star</h3><p><a href="https://github.com/holtenko/DesignPatterns/tree/master/src/AbstractFactory" target="_blank" rel="noopener">抽象工厂模式源码：https://github.com/holtenko/DesignPatterns/tree/master/src/AbstractFactory</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;系列回顾&quot;&gt;&lt;a href=&quot;#系列回顾&quot; class=&quot;headerlink&quot; title=&quot;系列回顾&quot;&gt;&lt;/a&gt;系列回顾&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.holten.site/2017/09/11/design-pattern-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;没事学点设计模式-概览&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.holten.site/2017/09/29/design-pattern-2/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;没事学点设计模式-工厂模式&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。&lt;/p&gt;
&lt;p&gt;在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。&lt;br&gt;
    
    </summary>
    
      <category term="Basic" scheme="http://blog.holten.com/categories/Basic/"/>
    
    
      <category term="设计模式" scheme="http://blog.holten.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>没事学点设计模式-工厂模式</title>
    <link href="http://blog.holten.com/2017/09/29/design-pattern-2/"/>
    <id>http://blog.holten.com/2017/09/29/design-pattern-2/</id>
    <published>2017-09-29T01:23:52.000Z</published>
    <updated>2018-02-12T05:50:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="系列回顾"><a href="#系列回顾" class="headerlink" title="系列回顾"></a>系列回顾</h3><ol><li><a href="http://blog.holten.site/2017/09/11/design-pattern-1/" target="_blank" rel="noopener">没事学点设计模式-概览</a></li></ol><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>工厂模式（Factory Pattern）是一种最常用的设计模式。这种类型的设计模式属于创建型模式，它提供了一种方便快捷创建对象的最佳方式。</p><p>在工厂模式中，我们在创建对象时不需要向调用方暴露创建对象的具体逻辑流程，并且是通过使用一个共同的接口来指向新创建的对象。工厂模式定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行，用以解决接口选择的问题。<br><a id="more"></a><br><strong>举例说明</strong></p><ol><li>我要买一辆汽车，我可以直接从工厂里面提货，而不用去关心这辆汽车是如何生产出来的，以及这个汽车里面的各种细节是什么样子的。</li><li>我要买一部手机，我也不需要知道手机是怎么制造出来的，我只需要知道我想要iPhoneX还是还是HUAWEI P10，工厂自然会帮我制造出来。</li></ol><p><strong>优点</strong></p><ol><li>创建一个对象，只要知道其名称就可以了，就比如我只需要知道那款手机叫iPhoneX就可以了；</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以了；</li><li>屏蔽具体实现，用户只关心接口即可。</li></ol><p><strong>缺点</strong><br>每增加一个实现时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。</p><p><strong>使用场景</strong></p><ol><li>日志记录器：记录可能记录到本地文件、远程服务器、打印到终端等，用户只需要知道要记录到哪里说明即可。</li><li>数据库访问：当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时，现在是Oracle，有可能换到MySQL等，此时只需换方言和驱动就可以。</li><li>设计一个连接服务器的框架，可以通过”TCP”或者”UDP”或者其他协议,可以把这些都作为产品类，共同实现一个接口即可。</li></ol><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>我们以生产iPhone的生产工厂为例。</p><h4 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h4><p>1.首先需要创建一个iphone接口和其实现类：接口iphone，实现类iphone7\iphone8\iphonex；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iphone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone7</span> <span class="keyword">implements</span> <span class="title">Iphone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"iphone7 get!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone8</span> <span class="keyword">implements</span> <span class="title">Iphone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"iphone8 get!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphonex</span> <span class="keyword">implements</span> <span class="title">Iphone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"iphonex get!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.然后定义工厂类iphoneFactory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IphoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">(String iphoneType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (iphoneType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (iphoneType.equalsIgnoreCase(<span class="string">"iphone7"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Iphone7();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iphoneType.equalsIgnoreCase(<span class="string">"iphone8"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Iphone8();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iphoneType.equalsIgnoreCase(<span class="string">"iphonex"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Iphonex();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>3.然后就可以随意生产了，比如先来一个iphonex哈哈哈<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IphoneFactory iphonefactory = <span class="keyword">new</span> IphoneFactory();</span><br><span class="line">        Iphone iphone = iphonefactory.getIphone(<span class="string">"iphonex"</span>);</span><br><span class="line">        iphone.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>1.首先需要创建一个iphone接口和其实现类：接口iphone，实现类iphone7\iphone8\iphonex；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iphone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone7</span> <span class="keyword">implements</span> <span class="title">Iphone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"iphone7 get!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone8</span> <span class="keyword">implements</span> <span class="title">Iphone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"iphone8 get!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphonex</span> <span class="keyword">implements</span> <span class="title">Iphone</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"iphonex get!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.然后定义工厂接口iphoneFactory<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IphoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><p>3.实现工厂接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone7Factory</span> <span class="keyword">implements</span> <span class="title">IphoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iphone7();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iphone8Factory</span> <span class="keyword">implements</span> <span class="title">IphoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iphone8();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IphonexFactory</span> <span class="keyword">implements</span> <span class="title">IphoneFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iphone <span class="title">getIphone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Iphonex();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.然后就也可以随意生产了，比如再来一个iphone8<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IphoneFactory iphonefactory = <span class="keyword">new</span> Iphone8Factory();</span><br><span class="line">        Iphone iphone = iphonefactory.getIphone();</span><br><span class="line">        iphone.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="本文源码已托管至GitHub，欢迎Star"><a href="#本文源码已托管至GitHub，欢迎Star" class="headerlink" title="本文源码已托管至GitHub，欢迎Star"></a>本文源码已托管至GitHub，欢迎Star</h3><p><a href="https://github.com/holtenko/DesignPatterns/tree/master/src/Factory" target="_blank" rel="noopener">工厂模式源码：https://github.com/holtenko/DesignPatterns/tree/master/src/Factory</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;系列回顾&quot;&gt;&lt;a href=&quot;#系列回顾&quot; class=&quot;headerlink&quot; title=&quot;系列回顾&quot;&gt;&lt;/a&gt;系列回顾&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://blog.holten.site/2017/09/11/design-pattern-1/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;没事学点设计模式-概览&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;工厂模式（Factory Pattern）是一种最常用的设计模式。这种类型的设计模式属于创建型模式，它提供了一种方便快捷创建对象的最佳方式。&lt;/p&gt;
&lt;p&gt;在工厂模式中，我们在创建对象时不需要向调用方暴露创建对象的具体逻辑流程，并且是通过使用一个共同的接口来指向新创建的对象。工厂模式定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行，用以解决接口选择的问题。&lt;br&gt;
    
    </summary>
    
      <category term="Basic" scheme="http://blog.holten.com/categories/Basic/"/>
    
    
      <category term="设计模式" scheme="http://blog.holten.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>没事学点设计模式-概览</title>
    <link href="http://blog.holten.com/2017/09/11/design-pattern-1/"/>
    <id>http://blog.holten.com/2017/09/11/design-pattern-1/</id>
    <published>2017-09-11T07:27:00.000Z</published>
    <updated>2019-08-22T12:00:21.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。设计模式使代码编制真正工程化，可以说设计模式是软件工程的基石。合理的使用设计模式可以使我们的代码具有更强的复用性和灵活的扩展性，这里面蕴含了很多前辈的经验，可以帮助我们少走很多弯路，完美地解决很多问题。</p><h3 id="有哪些设计模式"><a href="#有哪些设计模式" class="headerlink" title="有哪些设计模式"></a>有哪些设计模式</h3><p>根据GOF所著的《设计模式-可复用的面向对象软件元素》中提到，共有23种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。<br><a id="more"></a></p><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:left">描述</th><th style="text-align:left">细分类型</th></tr></thead><tbody><tr><td style="text-align:center">创建型模式</td><td style="text-align:left">这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活.</td><td style="text-align:left"><a href="http://blog.holten.site/2017/09/29/design-pattern-2/" target="_blank" rel="noopener">工厂模式（Factory Pattern）</a><br><a href="http://blog.holten.site/2018/02/12/design-pattern-3/" target="_blank" rel="noopener">抽象工厂模式（Abstract Factory Pattern）</a><br><a href="http://blog.holten.site/2018/03/22/design-pattern-4/" target="_blank" rel="noopener">单例模式（Singleton Pattern</a><br>建造者模式（Builder Pattern）<br>原型模式（Prototype Pattern）</td></tr><tr><td style="text-align:center">结构型模式</td><td style="text-align:left">这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td style="text-align:left">适配器模式（Adapter Pattern）<br>桥接模式（Bridge Pattern）<br>过滤器模式（Filter、Criteria Pattern）<br>组合模式（Composite Pattern）<br>装饰器模式（Decorator Pattern）<br>外观模式（Facade Pattern）<br>享元模式（Flyweight Pattern）<br>代理模式（Proxy Pattern）</td></tr><tr><td style="text-align:center">行为型模式</td><td style="text-align:left">这些设计模式特别关注对象之间的通信。</td><td style="text-align:left">责任链模式（Chain of Responsibility Pattern）<br>命令模式（Command Pattern）<br>解释器模式（Interpreter Pattern）<br>迭代器模式（Iterator Pattern）<br>中介者模式（Mediator Pattern）<br>备忘录模式（Memento Pattern）<br>观察者模式（Observer Pattern）<br>状态模式（State Pattern）<br>空对象模式（Null Object Pattern）<br>策略模式（Strategy Pattern）<br>模板模式（Template Pattern）<br>访问者模式（Visitor Pattern）</td></tr></tbody></table><h3 id="设计模式的原则"><a href="#设计模式的原则" class="headerlink" title="设计模式的原则"></a>设计模式的原则</h3><ol><li>开闭原则（Open Close Principle）<br>对扩展开放，对修改关闭。在程序需要进行扩展的时候，不去修改原代码，实现热插拔效果。目的是为了使程序的扩展性好，易于维护和升级。为此需要使用接口和抽象类。</li><li>里氏代换原则（Liskov Substitution Principle）<br>里氏代换原则是面向对象设计的基本原则之一。任何基类可以出现的地方，子类一定可以出现。这个原则是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</li><li>依赖反转原则（Dependence Inversion Principle）<br>这是开闭原则的基础。针对接口编程，依赖于抽象而不依赖于具体。</li><li>接口隔离原则（Interface Segregation Principle）<br>使用多个隔离的接口，比使用单个接口要好。此外还可以降低类之间的耦合度。</li><li>迪米特法则，又称最少知道原则（Demeter Principle）<br>一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</li><li>合成复用原则（Composite Reuse Principle）<br>尽量使用合成/聚合的方式，而不是使用继承。</li></ol><p><strong>后面的文章会详细介绍其中部分设计模式</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;什么是设计模式&quot;&gt;&lt;a href=&quot;#什么是设计模式&quot; class=&quot;headerlink&quot; title=&quot;什么是设计模式&quot;&gt;&lt;/a&gt;什么是设计模式&lt;/h3&gt;&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。设计模式使代码编制真正工程化，可以说设计模式是软件工程的基石。合理的使用设计模式可以使我们的代码具有更强的复用性和灵活的扩展性，这里面蕴含了很多前辈的经验，可以帮助我们少走很多弯路，完美地解决很多问题。&lt;/p&gt;
&lt;h3 id=&quot;有哪些设计模式&quot;&gt;&lt;a href=&quot;#有哪些设计模式&quot; class=&quot;headerlink&quot; title=&quot;有哪些设计模式&quot;&gt;&lt;/a&gt;有哪些设计模式&lt;/h3&gt;&lt;p&gt;根据GOF所著的《设计模式-可复用的面向对象软件元素》中提到，共有23种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。&lt;br&gt;
    
    </summary>
    
      <category term="Basic" scheme="http://blog.holten.com/categories/Basic/"/>
    
    
      <category term="设计模式" scheme="http://blog.holten.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot那些事(0)-入门篇</title>
    <link href="http://blog.holten.com/2017/07/21/spring-boot-0-intro/"/>
    <id>http://blog.holten.com/2017/07/21/spring-boot-0-intro/</id>
    <published>2017-07-21T08:21:53.000Z</published>
    <updated>2019-08-22T12:00:21.699Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Spring-Boot"><a href="#什么是Spring-Boot" class="headerlink" title="什么是Spring Boot"></a>什么是Spring Boot</h4><p>读研期间主要写的是Java后端，工作之后开始更多地接触Node.js写后端程序，有对比才有伤害，让我深深的感受到了Java的重量级，开发的时候各种配置，部署的时候还有一堆要忙活，相对而言Node.js之类的新兴的后端语言显得格外的清新小巧。如果你觉得既然如此就可以就此放弃Java了，那就太草率了，毕竟Java作为后端主流语言不会就这么自甘堕落，Spring Boot应运而生，虽然很早之前就听过Spring Boot的大名，但是碍于当时论文的压力，一直没有深入地去了解，最近项目需要正好可以搞一搞熟悉一下。<br><a id="more"></a><br>Spring Boot推崇的是”习惯优于配置“，通俗的说可以这么理解，原来一个即使很简单的项目也需要有一大把的配置，但是后来发现很多时候大部分的配置都是一样的，你也会这么配，我也会这么配，但是如果你不知道你就不会配，你仍然需要去了解茫茫多的配置项才能运行一个其实非常简单的项目，当你陷入这种境地的时候，Spring Boot就给你带来了曙光，你可以摆脱大部分的通用配置，框架内置一套习惯的配置，你只需要对你需要的部分进行定制即可。</p><p>以前Java项目另外一个痛点就是部署，项目无论大小都需要配置一台服务器(Tomcat等)，然后把项目打包部署上去，所以你还要懂一套服务器部署的内容，可是明明有些项目就很简单啊，非要搞这么复杂，Spring Boot则告诉你，原来Java项目开发也可以很简单，框架内置了一个轻量级的Servlet容器(Tomcat或者Jetty等)，让你很容易地创建一个独立运行项目，只需一个命令，你就可以向运行普通Java程序一样运行一个Java后端程序，是不是很爽！</p><h4 id="Spring-Boot主要特点"><a href="#Spring-Boot主要特点" class="headerlink" title="Spring Boot主要特点"></a>Spring Boot主要特点</h4><ol><li><p>能够独立运行<br>Spring Boot创建的程序最终会打成一个jar包，因此，只需要<code>java -jar your-project-name.jar</code>一句命令就可以运行起来了。</p></li><li><p>内置Servlet容器<br>Spring Boot项目会内置一个容器，如Tomcat、Jetty等，这样我们就不需要再额外配置服务器去部署了。</p></li><li><p>自动装配<br>从spring最原始的xml配置bean一路走来，曾几何时觉得<code>@Autowired</code>自动装配已经非常好用了，而Spring Boot则可以根据类路径中的jar包、类，为jar包里的类自动装配bean，这样就更进一步地减少了配置的工作量。但是嘛，自动的总会出问题的，它并不能帮你解决任何问题，当你发现它做的不够的时候，还是需要手动地去配置一下，但是相比而言，它也能够应付一部分场景了。</p></li><li><p>摆脱繁杂的XML和代码配置<br>Spring 4.x里已经可以通过注解来实现配置了，而Spring Boot则把这一特性发挥到了极致，一个项目里你甚至可以不写一行xml，不写一行配置代码，就可以完成。</p></li><li><p>简化的Maven配置<br>Maven的出现已经可以帮我解决了很多依赖的问题，不用再一个一个jar包去下载导入，但是有没有这么一种感觉，我还是要在pom里面写很多，而且有时候我根本不知道要添加哪个jar包，这一点Spring Boot也想到了，它提供了一系列starter来简化Maven依赖，比如你只需要添加一个<code>spring-boot-starter-web</code>，如下，就可添加web开发中常用的依赖包。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="从哪里开始"><a href="#从哪里开始" class="headerlink" title="从哪里开始"></a>从哪里开始</h4><ol><li><a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a><br>说了那么多Spring Boot的好处，怎么开始呢？这一点也充分体现了其简单的特点，非常方便。</li></ol><p>访问<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a> ，就可以看到Spring Boot官方的项目生成页面，你只需要填写项目的信息，选择一下依赖，然后点击<code>Generate Project</code>就可以生成项目文件并下载zip包。</p><p>在这里可以选择使用Maven管理还是Gradle管理项目依赖，使用Java、Kotlin还是Groovy，还有Spring Boot的版本，打包方式，Java版本，等等，其他的可以自行查看。当然即使生成项目的时候填错了也没关系，后面还可以改嘛。</p><ol><li>手动创建<br>求人不如求己，有时候你还是需要知道如何手动的去创建一个项目，说到底，所有的生成工具帮你生成还是一个Maven项目，或者Gradle项目，只不过是帮你填写好了一些信息而已，你完全可以自己手动填写。</li></ol><p>这里以Maven项目为例：</p><ol><li>首先你需要新建一个空的Maven项目，这个就不说了，不会的去面壁；</li><li><p>添加Spring Boot父依赖，提供相关的默认依赖，指定版本号，如下；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加相关starter<br>比如这里添加了web支持和security支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>添加编译插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>完成</p></li><li><p>其他方式<br>除了这两种方式之外还有其他一些方式，比如Spring Boot CLI、Spring Tool Suite等等，这些就不做介绍了。</p><h4 id="如何开始"><a href="#如何开始" class="headerlink" title="如何开始"></a>如何开始</h4></li></ol><p>这里采用在<code>http://start.spring.io</code>上新建项目后下载，这是下载之后的文件目录：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── mvnw</span><br><span class="line">├── mvnw.cmd</span><br><span class="line">├── pom.xml</span><br><span class="line">└── src</span><br><span class="line">    ├── main</span><br><span class="line">    │   ├── java</span><br><span class="line">    │   │   └── site</span><br><span class="line">    │   │       └── holten</span><br><span class="line">    │   │           └── springboot0</span><br><span class="line">    │   │               └── Springboot0Application.java</span><br><span class="line">    │   └── resources</span><br><span class="line">    │       └── application.properties</span><br><span class="line">    └── <span class="built_in">test</span></span><br><span class="line">        └── java</span><br><span class="line">            └── site</span><br><span class="line">                └── holten</span><br><span class="line">                    └── springboot0</span><br><span class="line">                        └── Springboot0ApplicationTests.java</span><br><span class="line">12 directories, 6 files</span><br></pre></td></tr></table></figure></p><p>我们首先看一下pom.xml，这里只添加了web starter：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>site.holten<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>作为简单示例，我们直接在<code>Springboot0Application.java</code>中编写代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> site.holten.springboot0;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Springboot0Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Springboot0Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">homepage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this is home page!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello/&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(@PathVariable String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello "</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里了解这么几点就可以了：</p><ul><li><code>SpringApplication.run(Springboot0Application.class, args)</code>：main方法中的这句话用来指定程序的入口；</li><li><code>@SpringBootApplication</code>：这个是最重要的，标识着这是一个Spring Boot项目，开启自动配置；</li><li><code>@RestController</code>：这个是Spring MVC里面的注解，组合了<code>@Controller</code>和<code>@ResponseBody</code>；</li><li><code>@RequestMapping</code>：用来映射请求路径/参数、处理类和方法；</li><li><code>@Controller</code>：表明这是一个Spring MVC的Controller，Dispatcher Servlet会自动扫描该类，发现其中的<code>@RequestMapping</code>注解并映射；</li><li><code>@ResponseBody</code>：用来支持把返回值放到response体内；</li></ul><p>代码写完了，如何运行呢？</p><ul><li>如果你是用的IDE，那么直接run或者debug就可以了；</li><li>如果没有，可以在命令行里运行<code>mvn spring-boot:run</code>，当然，前提是你要安装了maven，并且在项目根目录下；</li><li>然后在地址栏输入<code>http://localhost:8080/</code>或者<code>http://localhost:8080/hello/yourname</code>就可以看到结果了；</li></ul><p>具体效果就不贴图了，自行体会～～～</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是Spring-Boot&quot;&gt;&lt;a href=&quot;#什么是Spring-Boot&quot; class=&quot;headerlink&quot; title=&quot;什么是Spring Boot&quot;&gt;&lt;/a&gt;什么是Spring Boot&lt;/h4&gt;&lt;p&gt;读研期间主要写的是Java后端，工作之后开始更多地接触Node.js写后端程序，有对比才有伤害，让我深深的感受到了Java的重量级，开发的时候各种配置，部署的时候还有一堆要忙活，相对而言Node.js之类的新兴的后端语言显得格外的清新小巧。如果你觉得既然如此就可以就此放弃Java了，那就太草率了，毕竟Java作为后端主流语言不会就这么自甘堕落，Spring Boot应运而生，虽然很早之前就听过Spring Boot的大名，但是碍于当时论文的压力，一直没有深入地去了解，最近项目需要正好可以搞一搞熟悉一下。&lt;br&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://blog.holten.com/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://blog.holten.com/tags/Java/"/>
    
      <category term="Spring Boot" scheme="http://blog.holten.com/tags/Spring-Boot/"/>
    
      <category term="入门" scheme="http://blog.holten.com/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>Java中创建线程的两种方式</title>
    <link href="http://blog.holten.com/2016/10/17/javaCreateThread/"/>
    <id>http://blog.holten.com/2016/10/17/javaCreateThread/</id>
    <published>2016-10-17T08:10:15.000Z</published>
    <updated>2019-08-22T12:00:21.699Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>多线程是我们开发过程中经常遇到的，也是必不可少需要掌握的。当我们知道需要进行多线程开发时首先需要知道的自然是如何实现多线程，也就是我们应该如何创建线程。</p><p>在Java中创建线程和创建普通的类的对象操作是一样的，我们可以通过两种方式来创建线程：</p><ol><li>继承Thread类，并重写run()方法。</li><li>实现Runnable接口，并实现run()方法。<a id="more"></a><h4 id="方法一：继承Thread类"><a href="#方法一：继承Thread类" class="headerlink" title="方法一：继承Thread类"></a>方法一：继承Thread类</h4>代码非常简单</li><li>首先重载一个构造函数，以便我们可以给线程命名。</li><li>重写run()方法。</li><li>这里我们先让线程输出线程名+start。</li><li>然后每5ms输出线程名+一个递增数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by holten.gao on 2016/10/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">threadThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.getName()+<span class="string">" start!"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>.getName()+<span class="string">" "</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法二：实现Runnable接口"><a href="#方法二：实现Runnable接口" class="headerlink" title="方法二：实现Runnable接口"></a>方法二：实现Runnable接口</h4><p>代码也非常简单</p><ol><li>实现run()方法。</li><li>这里我们先让线程输出线程名+start。</li><li>然后每5ms输出线程名+一个递增数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by holten.gao on 2016/10/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">runnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">" start!"</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>测试代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by holten.gao on 2016/10/17.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadThread=<span class="keyword">new</span> threadThread(<span class="string">"threadThread"</span>);</span><br><span class="line">        threadThread.start();</span><br><span class="line">        Thread runnableThread=<span class="keyword">new</span> Thread(<span class="keyword">new</span> runnableThread(),<span class="string">"runnableThread"</span>);</span><br><span class="line">        runnableThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试结果<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">threadThread start!</span><br><span class="line">threadThread 0</span><br><span class="line">runnableThread start!</span><br><span class="line">runnableThread 0</span><br><span class="line">threadThread 1</span><br><span class="line">runnableThread 1</span><br><span class="line">threadThread 2</span><br><span class="line">runnableThread 2</span><br><span class="line">threadThread 3</span><br><span class="line">runnableThread 3</span><br><span class="line">threadThread 4</span><br><span class="line">runnableThread 4</span><br><span class="line">threadThread 5</span><br><span class="line">runnableThread 5</span><br><span class="line">threadThread 6</span><br><span class="line">runnableThread 6</span><br><span class="line">threadThread 7</span><br><span class="line">runnableThread 7</span><br><span class="line">threadThread 8</span><br><span class="line">runnableThread 8</span><br><span class="line">threadThread 9</span><br><span class="line">runnableThread 9</span><br></pre></td></tr></table></figure></p><h4 id="两种方法比较"><a href="#两种方法比较" class="headerlink" title="两种方法比较"></a>两种方法比较</h4><ol><li>因为Java只支持单继承，所以使用方法一就不能再继承其他类了；而方法二实现接口则不会影响继承其他类。</li><li>方法一由于是继承Thread，所以直接new出来就可以start；而方法二需要将对象作为参数传入Thread对象才能得到Thread对象。</li><li>方法一中可以直接通过this.getName获得线程名；而方法二需要Thread.currentThread().getName()获得</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;多线程是我们开发过程中经常遇到的，也是必不可少需要掌握的。当我们知道需要进行多线程开发时首先需要知道的自然是如何实现多线程，也就是我们应该如何创建线程。&lt;/p&gt;
&lt;p&gt;在Java中创建线程和创建普通的类的对象操作是一样的，我们可以通过两种方式来创建线程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;继承Thread类，并重写run()方法。&lt;/li&gt;
&lt;li&gt;实现Runnable接口，并实现run()方法。
    
    </summary>
    
      <category term="Java" scheme="http://blog.holten.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.holten.com/tags/Java/"/>
    
      <category term="线程" scheme="http://blog.holten.com/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="Thread" scheme="http://blog.holten.com/tags/Thread/"/>
    
  </entry>
  
  <entry>
    <title>Java中字符串内存位置浅析</title>
    <link href="http://blog.holten.com/2016/08/16/StringMemory/"/>
    <id>http://blog.holten.com/2016/08/16/StringMemory/</id>
    <published>2016-08-16T05:12:56.000Z</published>
    <updated>2019-08-22T12:00:21.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前写过一篇关于<a href="http://blog.holten.site/2016/04/09/JVM-memory-area/" target="_blank" rel="noopener">JVM内存区域划分</a>的文章，但是昨天接到蚂蚁金服的面试，问到JVM相关的内容，解释一下JVM的内存区域划分，这部分答得还不错，但是后来又问了Java里面String存放的位置，之前只记得String是一个不变的量，应该是要存放在常量池里面的，但是后来问到new一个String出来应该是放到哪里的，这个应该是放到堆里面的，后来又问到String的引用是放在什么地方的，当时傻逼的说也是放在堆里面的，现在总结一下：基本类型的变量数据和对象的引用都是放在栈里面的，对象本身放在堆里面，显式的String常量放在常量池，String对象放在堆中。<br><a id="more"></a></p><h3 id="常量池的说明"><a href="#常量池的说明" class="headerlink" title="常量池的说明"></a>常量池的说明</h3><p>常量池之前是放在方法区里面的，也就是在永久代里面的，从JDK7开始移到了堆里面。这一改变我们可以从oracle的<a href="http://www.oracle.com/technetwork/java/javase/jdk7-relnotes-418459.html" target="_blank" rel="noopener">release version</a>的notes里的<strong> Important RFEs Addressed in JDK 7 </strong>看到。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Area: HotSpot</span><br><span class="line">Synopsis: In JDK 7, interned strings are no longer allocated in the permanent </span><br><span class="line">generation of the Java heap, but are instead allocated in the main part of the </span><br><span class="line">Java heap (known as the young and old generations), along with the other </span><br><span class="line">objects created by the application. This change will result in more data </span><br><span class="line">residing in the main Java heap, and less data in the permanent generation, and </span><br><span class="line">thus may require heap sizes to be adjusted. Most applications will see only </span><br><span class="line">relatively small differences in heap usage due to this change, but larger </span><br><span class="line">applications that load many classes or make heavy use of the String.intern() </span><br><span class="line">method will see more significant differences.</span><br><span class="line">RFE: 6962931</span><br></pre></td></tr></table></figure></p><h3 id="String内存位置说明"><a href="#String内存位置说明" class="headerlink" title="String内存位置说明"></a>String内存位置说明</h3><p>1.显式的String常量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="string">"holten"</span>;</span><br><span class="line">String b = <span class="string">"holten"</span>;</span><br></pre></td></tr></table></figure></p><ul><li>第一句代码执行后就在常量池中创建了一个值为holten的String对象；</li><li>第二句执行时，因为常量池中存在holten所以就不再创建新的String对象了。</li><li>此时该字符串的引用在虚拟机栈里面。</li></ul><p>2.String对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String a = <span class="keyword">new</span> String(<span class="string">"holtenObj"</span>);</span><br><span class="line">String b = <span class="keyword">new</span> String(<span class="string">"holtenObj"</span>);</span><br></pre></td></tr></table></figure></p><ul><li>Class被加载时就在常量池中创建了一个值为holtenObj的String对象，第一句执行时会在堆里创建new String(“holtenObj”)对象；</li><li>第二句执行时，因为常量池中存在holtenObj所以就不再创建新的String对象了，直接在堆里创建new String(“holtenObj”)对象。</li></ul><h3 id="验证一下"><a href="#验证一下" class="headerlink" title="验证一下"></a>验证一下</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by holten.gao on 2016/8/16.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">"高小天"</span>;</span><br><span class="line">        String str2 = <span class="string">"高小天"</span>;</span><br><span class="line">        System.out.println(str1==str2);<span class="comment">//true</span></span><br><span class="line">        </span><br><span class="line">        String str3 = <span class="keyword">new</span> String(<span class="string">"高大天"</span>);</span><br><span class="line">        String str4 = <span class="keyword">new</span> String(<span class="string">"高大天"</span>);</span><br><span class="line">        System.out.println(str3==str4);<span class="comment">//false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回结果：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前写过一篇关于&lt;a href=&quot;http://blog.holten.site/2016/04/09/JVM-memory-area/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVM内存区域划分&lt;/a&gt;的文章，但是昨天接到蚂蚁金服的面试，问到JVM相关的内容，解释一下JVM的内存区域划分，这部分答得还不错，但是后来又问了Java里面String存放的位置，之前只记得String是一个不变的量，应该是要存放在常量池里面的，但是后来问到new一个String出来应该是放到哪里的，这个应该是放到堆里面的，后来又问到String的引用是放在什么地方的，当时傻逼的说也是放在堆里面的，现在总结一下：基本类型的变量数据和对象的引用都是放在栈里面的，对象本身放在堆里面，显式的String常量放在常量池，String对象放在堆中。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.holten.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.holten.com/tags/Java/"/>
    
      <category term="内存" scheme="http://blog.holten.com/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="String" scheme="http://blog.holten.com/tags/String/"/>
    
  </entry>
  
  <entry>
    <title>Lombok介绍及使用方法</title>
    <link href="http://blog.holten.com/2016/08/02/LombokIntroduction/"/>
    <id>http://blog.holten.com/2016/08/02/LombokIntroduction/</id>
    <published>2016-08-02T03:19:01.000Z</published>
    <updated>2019-08-22T12:00:21.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="lombok简介"><a href="#lombok简介" class="headerlink" title="lombok简介"></a>lombok简介</h3><p>lombok是暑假来到公司实习的时候发现的一个非常好用的小工具，刚见到的时候就感觉非常惊艳，有一种相见恨晚的感觉，用了一段时间之后感觉的确挺不错，所以特此来推荐一下。</p><p><a href="https://projectlombok.org/" target="_blank" rel="noopener">lombok的官方地址：https://projectlombok.org/</a></p><p><a href="https://github.com/rzwitserloot/lombok" target="_blank" rel="noopener">lombok的Github地址：https://github.com/rzwitserloot/lombok</a></p><p>那么lombok到底是个什么呢，lombok是一个可以通过简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 Java 代码的工具，简单来说，比如我们新建了一个类，然后在其中写了几个字段，然后通常情况下我们需要手动去建立getter和setter方法啊，构造函数啊之类的，lombok的作用就是为了省去我们手动创建这些代码的麻烦，它能够在我们编译源码的时候自动帮我们生成这些方法。<br><a id="more"></a><br>lombok能够达到的效果就是在源码中不需要写一些通用的方法，但是在编译生成的字节码文件中会帮我们生成这些方法，这就是lombok的神奇作用。</p><p>虽然有人可能会说IDE里面都自带自动生成这些方法的功能，但是使用lombok会使你的代码看起来更加简洁，写起来也更加方便。</p><h3 id="lombok安装"><a href="#lombok安装" class="headerlink" title="lombok安装"></a>lombok安装</h3><p>lombok的安装跟一般引用jar包没有什么区别，可以到官网上下载最新的jar包，然后导入到项目里面就好啦。</p><p><strong>Maven添加依赖</strong><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>Intellij idea开发的话需要安装Lombok plugin，同时设置 Setting -&gt; Compiler -&gt; Annotation Processors -&gt; Enable annotation processing勾选。</p><h3 id="lombok使用"><a href="#lombok使用" class="headerlink" title="lombok使用"></a>lombok使用</h3><p>lombok使用过程中主要是靠注解起作用的，官网上的文档里面有所有的注解，这里不一一罗列，只说明其中几个比较常用的。</p><h4 id="NonNull-可以帮助我们避免空指针。"><a href="#NonNull-可以帮助我们避免空指针。" class="headerlink" title="@NonNull: 可以帮助我们避免空指针。"></a><code>@NonNull</code>: 可以帮助我们避免空指针。</h4><p>使用lombok：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.NonNull;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonNullExample</span> <span class="keyword">extends</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">NonNullExample</span><span class="params">(@NonNull Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = person.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用lombok：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NonNullExample</span> <span class="keyword">extends</span> <span class="title">Something</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonNullExample</span><span class="params">(@NonNull Person person)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"Hello"</span>);</span><br><span class="line">        <span class="keyword">if</span> (person == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"person"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = person.getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Cleanup-自动帮我们调用close-方法。"><a href="#Cleanup-自动帮我们调用close-方法。" class="headerlink" title="@Cleanup: 自动帮我们调用close()方法。"></a><code>@Cleanup</code>: 自动帮我们调用<code>close()</code>方法。</h4><p>使用lombok：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Cleanup;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanupExample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="meta">@Cleanup</span> InputStream in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="meta">@Cleanup</span> OutputStream out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> r = in.read(b);</span><br><span class="line">            <span class="keyword">if</span> (r == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            out.write(b, <span class="number">0</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用lombok：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanupExample</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            InputStream in = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                OutputStream out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10000</span>];</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = in.read(b);</span><br><span class="line">                    <span class="keyword">if</span> (r == -<span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">                    out.write(b, <span class="number">0</span>, r);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (out != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        out.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Getter-Setter-自动生成Getter-Setter方法"><a href="#Getter-Setter-自动生成Getter-Setter方法" class="headerlink" title="@Getter / @Setter: 自动生成Getter/Setter方法"></a><code>@Getter / @Setter</code>: 自动生成Getter/Setter方法</h4><p>使用lombok：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AccessLevel;</span><br><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetterSetterExample</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span> <span class="meta">@Setter</span> <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Setter</span>(AccessLevel.PROTECTED) <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不使用lombok：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetterSetterExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="NoArgsConstructor-自动生成无参数构造函数。"><a href="#NoArgsConstructor-自动生成无参数构造函数。" class="headerlink" title="@NoArgsConstructor: 自动生成无参数构造函数。"></a><code>@NoArgsConstructor</code>: 自动生成无参数构造函数。</h4><h4 id="AllArgsConstructor-自动生成全参数构造函数。"><a href="#AllArgsConstructor-自动生成全参数构造函数。" class="headerlink" title="@AllArgsConstructor: 自动生成全参数构造函数。"></a><code>@AllArgsConstructor</code>: 自动生成全参数构造函数。</h4><h4 id="Data-自动为所有字段添加-ToString-EqualsAndHashCode-Getter方法，为非final字段添加-Setter-和-RequiredArgsConstructor"><a href="#Data-自动为所有字段添加-ToString-EqualsAndHashCode-Getter方法，为非final字段添加-Setter-和-RequiredArgsConstructor" class="headerlink" title="@Data: 自动为所有字段添加@ToString, @EqualsAndHashCode, @Getter方法，为非final字段添加@Setter,和@RequiredArgsConstructor!"></a><code>@Data</code>: 自动为所有字段添加@ToString, @EqualsAndHashCode, @Getter方法，为非final字段添加@Setter,和@RequiredArgsConstructor!</h4><p><strong><em>还有其他一些比如自动生成日志对象等等之类的注解可以到官方网站去了解，就不一一列举了。</em></strong></p><p><strong><a href="https://projectlombok.org/features/index.html" target="_blank" rel="noopener">官方文档https://projectlombok.org/features/index.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;lombok简介&quot;&gt;&lt;a href=&quot;#lombok简介&quot; class=&quot;headerlink&quot; title=&quot;lombok简介&quot;&gt;&lt;/a&gt;lombok简介&lt;/h3&gt;&lt;p&gt;lombok是暑假来到公司实习的时候发现的一个非常好用的小工具，刚见到的时候就感觉非常惊艳，有一种相见恨晚的感觉，用了一段时间之后感觉的确挺不错，所以特此来推荐一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://projectlombok.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lombok的官方地址：https://projectlombok.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rzwitserloot/lombok&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lombok的Github地址：https://github.com/rzwitserloot/lombok&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么lombok到底是个什么呢，lombok是一个可以通过简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 Java 代码的工具，简单来说，比如我们新建了一个类，然后在其中写了几个字段，然后通常情况下我们需要手动去建立getter和setter方法啊，构造函数啊之类的，lombok的作用就是为了省去我们手动创建这些代码的麻烦，它能够在我们编译源码的时候自动帮我们生成这些方法。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.holten.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.holten.com/tags/Java/"/>
    
      <category term="Lombok" scheme="http://blog.holten.com/tags/Lombok/"/>
    
  </entry>
  
  <entry>
    <title>排序算法之冒泡排序</title>
    <link href="http://blog.holten.com/2016/05/08/bubblesort/"/>
    <id>http://blog.holten.com/2016/05/08/bubblesort/</id>
    <published>2016-05-08T08:43:27.000Z</published>
    <updated>2019-08-22T12:00:21.695Z</updated>
    
    <content type="html"><![CDATA[<h3 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h3><p>冒泡排序是一种最基础也是最简单的排序算法，它是一种<strong>稳定</strong>排序算法，其平均时间复杂度为$O(n^2)$，空间复杂度为$O(1)$，是一种原地排序算法。</p><h3 id="算法原理-从后往前冒泡"><a href="#算法原理-从后往前冒泡" class="headerlink" title="算法原理(从后往前冒泡)"></a>算法原理(从后往前冒泡)</h3><p>冒泡排序的思想其实很简单，就是从最后一个元素开始，依次与其前面的元素作比较，如果位置错误就交换位置，否则不采取操作，一直到第一个元素，此时第一个元素一定是最大(最小)的元素；然后重复上述操作一直到第二个元素；然后一直对越来越少的元素进行比较和交换位置；直到所有元素都不再需要比较，排序完成。<br><a id="more"></a></p><h3 id="算法实现-Java"><a href="#算法实现-Java" class="headerlink" title="算法实现(Java)"></a>算法实现(Java)</h3><p>该示例为从小到大排序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span>[] a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = a.length - <span class="number">1</span>; j &gt; i; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &lt; a[j - <span class="number">1</span>]) exch(a, j, j - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序过程及结果"><a href="#排序过程及结果" class="headerlink" title="排序过程及结果"></a>排序过程及结果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Origin:</span><br><span class="line">2 1 6 4 9 5 3 1 7 8</span><br><span class="line">Process:</span><br><span class="line">2 1 6 4 9 5 1 3 7 8</span><br><span class="line">2 1 6 4 9 1 5 3 7 8</span><br><span class="line">2 1 6 4 1 9 5 3 7 8</span><br><span class="line">2 1 6 1 4 9 5 3 7 8</span><br><span class="line">2 1 1 6 4 9 5 3 7 8</span><br><span class="line">1 2 1 6 4 9 5 3 7 8</span><br><span class="line">1 2 1 6 4 9 3 5 7 8</span><br><span class="line">1 2 1 6 4 3 9 5 7 8</span><br><span class="line">1 2 1 6 3 4 9 5 7 8</span><br><span class="line">1 2 1 3 6 4 9 5 7 8</span><br><span class="line">1 1 2 3 6 4 9 5 7 8</span><br><span class="line">1 1 2 3 6 4 5 9 7 8</span><br><span class="line">1 1 2 3 4 6 5 9 7 8</span><br><span class="line">1 1 2 3 4 6 5 7 9 8</span><br><span class="line">1 1 2 3 4 5 6 7 9 8</span><br><span class="line">1 1 2 3 4 5 6 7 8 9</span><br><span class="line">Result:</span><br><span class="line">1 1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;算法简介&quot;&gt;&lt;a href=&quot;#算法简介&quot; class=&quot;headerlink&quot; title=&quot;算法简介&quot;&gt;&lt;/a&gt;算法简介&lt;/h3&gt;&lt;p&gt;冒泡排序是一种最基础也是最简单的排序算法，它是一种&lt;strong&gt;稳定&lt;/strong&gt;排序算法，其平均时间复杂度为$O(n^2)$，空间复杂度为$O(1)$，是一种原地排序算法。&lt;/p&gt;
&lt;h3 id=&quot;算法原理-从后往前冒泡&quot;&gt;&lt;a href=&quot;#算法原理-从后往前冒泡&quot; class=&quot;headerlink&quot; title=&quot;算法原理(从后往前冒泡)&quot;&gt;&lt;/a&gt;算法原理(从后往前冒泡)&lt;/h3&gt;&lt;p&gt;冒泡排序的思想其实很简单，就是从最后一个元素开始，依次与其前面的元素作比较，如果位置错误就交换位置，否则不采取操作，一直到第一个元素，此时第一个元素一定是最大(最小)的元素；然后重复上述操作一直到第二个元素；然后一直对越来越少的元素进行比较和交换位置；直到所有元素都不再需要比较，排序完成。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://blog.holten.com/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="http://blog.holten.com/tags/Algorithm/"/>
    
      <category term="Sort" scheme="http://blog.holten.com/tags/Sort/"/>
    
      <category term="排序" scheme="http://blog.holten.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="算法" scheme="http://blog.holten.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存回收对象及引用分析</title>
    <link href="http://blog.holten.com/2016/04/21/jvm-gc-objectreference/"/>
    <id>http://blog.holten.com/2016/04/21/jvm-gc-objectreference/</id>
    <published>2016-04-21T13:58:36.000Z</published>
    <updated>2019-08-22T12:00:21.699Z</updated>
    
    <content type="html"><![CDATA[<p>自动垃圾回收是Java相较于C++的一个重要的特点，想了解JVM的垃圾回收机制，首先我们要知道垃圾回收是回收什么地方的垃圾，我在我的上一篇博客《<a href="http://blog.holten.site/2016/04/09/JVM-memory-area/" target="_blank" rel="noopener">JVM内存区域划分</a>》里面有写到JVM里面的内存是怎么分布的，这里的回收主要是指对上文中提到的Java堆和方法区的内存的回收。</p><h3 id="什么样的对象可以被回收"><a href="#什么样的对象可以被回收" class="headerlink" title="什么样的对象可以被回收"></a>什么样的对象可以被回收</h3><p>知道了回收哪里的内存之后，我们还需要知道什么样的对象是可以被回收，或者说是需要被回收的，这些对象我们称之为死掉的对象。那么哪些对象是死掉了的呢？我们说当一个对象不存在任何引用的时候就可以说这个对象是死掉了。</p><p>那么什么时候这个对象不存在任何引用了呢？<br><a id="more"></a><br>有一些地方说，可以使用引用计数算法来判断对象是否还存活，引用计数算法是说给对象添加一个引用计数器，每当一个地方引用它时就加1，引用失效时就减1，计数器的值变为0就说这个对象不存在任何引用了，但是这样会存在一个很严重的问题，就是循环引用的问题。比如如下的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> Object instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Example objA=<span class="keyword">new</span> Example();</span><br><span class="line">    Example objB=<span class="keyword">new</span> Example();</span><br><span class="line"></span><br><span class="line">    objA.instance=objB;</span><br><span class="line">    objB.instance=objA;</span><br><span class="line"></span><br><span class="line">    objA=<span class="keyword">null</span>;</span><br><span class="line">    objB=<span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样的话，objA和objB的引用计数都不为0，但是他们的确是不会再被使用的了。</p><p>那么Java里面是用什么样的算法来实现对引用的判断的呢？</p><p>Java里是使用可达性分析的方法来实现的。</p><p><img src="http://oar4g068j.bkt.clouddn.com/GCObject.png" alt=""></p><p>如图所示，就是通过一系列的称为”GC Roots”的对象作为起始点，从这些点向下搜索，搜索的路径称为引用链，当一个对象到达GC Roots没有任何引用链时，就可以证明这个对象是不可用的。那么这个对象就可以被回收了。像图中的Obj1-5都属于存活的对象，但是Obj6-8虽然还存在相互引用，但是已经是可以认为是死掉的对象了。</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>目前来说，Java中的引用可以分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)四种，他们的引用顺序依次逐渐减弱。</p><ul><li><strong>强引用</strong>是用来描述必须存在和引用的对象，比如Object a=new Object()，只要强引用还存在，被引用的对象就永远不会被回收。</li><li><strong>软引用</strong>是用来描述一些还有用但是不是必需的对象。这类引用的对象会在内存溢出之前被列入回收范围进行第二次回收，如若回收完之后还没有获得足够的内存才会抛出内存溢出异常。可以使用SoftReference类来实现。</li><li><strong>弱引用</strong>是用来描述非必需的对象，但是强度比软引用更弱，被引用的对象只能存活到下一次GC之前。当进行GC的时候不论内存是否足够都会对该引用的对象进行回收。可以使用WeakReference类来实现。</li><li><strong>虚引用</strong>是最弱的引用关系。虚引用的存在不会对对象的存活造成任何影响，也不能通过虚引用来获得任何对象实例。设置虚引用的唯一目的就是在关联对象被回收时会获得一个系统通知。可以使用PhantomReference类来实现。</li></ul><h3 id="死亡对象的自我救赎"><a href="#死亡对象的自我救赎" class="headerlink" title="死亡对象的自我救赎"></a>死亡对象的自我救赎</h3><p>当一个对象在进行可达性分析的时候发现已经是没有任何引用的了，这时候垃圾收集器并没有立即判处该对象死刑，而是给了它一次自我救赎的机会，这时它会被标记一次，同时判断是不是有必要执行finalize()方法，当对象没有重写finalize()方法或者finalize()方法已经被执行过的时候，就不执行finalize()方法。下面就会有两种情况发生了：</p><ul><li>执行finalize()方法：这时这个对象会被放在F-Queue队列之中，然后由虚拟机自动创建一个低优先级的Finalizer线程去执行它，但是为了保证F-Queue不被无限阻塞并不保证一定会等待它执行结束。此时在finalize()里如果对象又重新获得与GC Roots的联系就可以完成自我救赎，否则的话就只能被第二次标记，然后听天由命了。</li><li>不执行finalize()方法：这时候要么是垃圾收集器已经给过一次机会了，要么是对象自己没有重写finalize()去获得机会，这个时候就只能被第二次标记，立即被执行死刑了。</li></ul><h3 id="方法区的回收"><a href="#方法区的回收" class="headerlink" title="方法区的回收"></a>方法区的回收</h3><p>方法区的回收分为废弃常量的回收和无用类的卸载。</p><ul><li>废弃常量的回收：回收废弃常量与上面所说的堆中对象的回收差不多，没有任何引用的时候回收。</li><li>无用类的卸载：类的卸载需要满足三个条件：</li></ul><ol><li>该类的所有对象都被回收。</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对应的java.lang.Class没有在任何地方被引用，无法在任何地方通过反射访问该类。<br>但是满足这三个条件只是说可以被回收，但是不代表一定被回收，具体是否被回收还要由虚拟机里的一些参数来具体确定。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;自动垃圾回收是Java相较于C++的一个重要的特点，想了解JVM的垃圾回收机制，首先我们要知道垃圾回收是回收什么地方的垃圾，我在我的上一篇博客《&lt;a href=&quot;http://blog.holten.site/2016/04/09/JVM-memory-area/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;JVM内存区域划分&lt;/a&gt;》里面有写到JVM里面的内存是怎么分布的，这里的回收主要是指对上文中提到的Java堆和方法区的内存的回收。&lt;/p&gt;
&lt;h3 id=&quot;什么样的对象可以被回收&quot;&gt;&lt;a href=&quot;#什么样的对象可以被回收&quot; class=&quot;headerlink&quot; title=&quot;什么样的对象可以被回收&quot;&gt;&lt;/a&gt;什么样的对象可以被回收&lt;/h3&gt;&lt;p&gt;知道了回收哪里的内存之后，我们还需要知道什么样的对象是可以被回收，或者说是需要被回收的，这些对象我们称之为死掉的对象。那么哪些对象是死掉了的呢？我们说当一个对象不存在任何引用的时候就可以说这个对象是死掉了。&lt;/p&gt;
&lt;p&gt;那么什么时候这个对象不存在任何引用了呢？&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.holten.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.holten.com/tags/Java/"/>
    
      <category term="jvm" scheme="http://blog.holten.com/tags/jvm/"/>
    
      <category term="内存回收" scheme="http://blog.holten.com/tags/%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6/"/>
    
      <category term="回收对象" scheme="http://blog.holten.com/tags/%E5%9B%9E%E6%94%B6%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="引用" scheme="http://blog.holten.com/tags/%E5%BC%95%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存区域划分</title>
    <link href="http://blog.holten.com/2016/04/09/JVM-memory-area/"/>
    <id>http://blog.holten.com/2016/04/09/JVM-memory-area/</id>
    <published>2016-04-09T07:20:35.000Z</published>
    <updated>2019-08-22T12:00:21.695Z</updated>
    
    <content type="html"><![CDATA[<p>学习Java不可避免的要学习Java虚拟机，也就是JVM，Java虚拟机规范里面规定了程序运行期间会使用到的运行时数据区，这也是JVM的内存区域划分的模型，应该可以这么理解吧。</p><p>这其中有一些是随着虚拟机的启动和退出而创建和销毁的，这些区域是线程共享的，另外有一些是跟各个线程绑定的，随着线程的开始和结束而创建和销毁，我们可以称这些区域是线程私有的。<br><a id="more"></a></p><p>根据《Java虚拟机规范Java SE 7版》和《Java虚拟机规范Java SE 8版》的规定，我们可以划分出如下几个运行时数据区，如下图所示：<br><img src="http://oar4g068j.bkt.clouddn.com/JVMDataArea.png" alt=""></p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>在Java虚拟机中，堆是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。这块区域随着虚拟机的启动而创建，它的唯一使命就是<strong>存放对象实例</strong>，这块区域也是GC主要关注的地方。</p><p>下面的就是我的笔记本上的JVM堆的划分情况，可以看到分为新生代、老年代和永久代，新生代里面有可以分为Eden Space、From Survivor Space和To Survivor Space。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 17301504 (16.5MB)</span><br><span class="line">   used     = 2483088 (2.3680572509765625MB)</span><br><span class="line">   free     = 14818416 (14.131942749023438MB)</span><br><span class="line">   14.351862127130682% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 2621440 (2.5MB)</span><br><span class="line">   used     = 2615312 (2.4941558837890625MB)</span><br><span class="line">   free     = 6128 (0.0058441162109375MB)</span><br><span class="line">   99.7662353515625% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 6291456 (6.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 6291456 (6.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 44564480 (42.5MB)</span><br><span class="line">   used     = 13316368 (12.699478149414062MB)</span><br><span class="line">   free     = 31248112 (29.800521850585938MB)</span><br><span class="line">   29.88112505744485% used</span><br><span class="line">PS Perm Generation</span><br><span class="line">   capacity = 22020096 (21.0MB)</span><br><span class="line">   used     = 14907008 (14.2164306640625MB)</span><br><span class="line">   free     = 7113088 (6.7835693359375MB)</span><br><span class="line">   67.6972888764881% used</span><br></pre></td></tr></table></figure></p><p>根据虚拟机规范的规定，Java堆可以是固定的大小也可以是按照需求动态扩展的，而且不需要保证是连续的。</p><p><strong>存放内容：</strong>所有的对象实例和数组。</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>方法区是一个线程共享的区域，它用于存储已被虚拟机加载的类信息、常量、静态变量。方法区是堆的逻辑组成部分，Hotspot用永久代实现了方法区。<br>方法区还包含运行时常量池(JDK1.7以后移到堆中)，用于存放编译时生成的各种字面量和符号引用，但是不要求常量一定是在编译时期产生的，运行期间也可以将新的常量放入池中，比如String的intern()方法便是利用了这一特性。</p><p><strong>存放内容：</strong>类的结构信息，如类的字段、方法、接口、构造函数，还有运行时常量池等。</p><h3 id="程序计数寄存器"><a href="#程序计数寄存器" class="headerlink" title="程序计数寄存器"></a>程序计数寄存器</h3><p>这块区域是每个线程独立拥有的，也就是线程私有的，我们可以把它看作是当前线程所执行的字节码的行号指示器。</p><p><strong>这块区域时虚拟机规范里面唯一一个没有规定任何OutOfMemoryError情况的区域。</strong></p><p><strong>存放内容：</strong>如果线程执行的是一个Java方法，那么寄存器里面记录的就是正在执行的虚拟机字节码指令的地址，如果线程执行的是一个native方法，那么寄存器记录的值为undefined。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>虚拟机栈也是线程私有的内存区域。每个方法在执行的时候都会创建一个栈帧用于存储局部变量表、操作数栈、方法出口等信息，每一个方法从调用到执行完成就是一个栈帧入栈和出栈的过程。</p><p>局部变量表存放了编译时期可知的各种基本数据类型、对象引用和指向了一条字节码指令的地址。</p><p><strong>存放内容：</strong>局部变量表、操作数栈、方法出口等信息。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈类似，存储Native方法的相关信息。<br><strong>存放内容：</strong>局部变量表、操作数栈、方法出口等信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;学习Java不可避免的要学习Java虚拟机，也就是JVM，Java虚拟机规范里面规定了程序运行期间会使用到的运行时数据区，这也是JVM的内存区域划分的模型，应该可以这么理解吧。&lt;/p&gt;
&lt;p&gt;这其中有一些是随着虚拟机的启动和退出而创建和销毁的，这些区域是线程共享的，另外有一些是跟各个线程绑定的，随着线程的开始和结束而创建和销毁，我们可以称这些区域是线程私有的。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.holten.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.holten.com/tags/Java/"/>
    
      <category term="内存" scheme="http://blog.holten.com/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="jvm" scheme="http://blog.holten.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>iTerm2和oh-my-zsh的个性化定制</title>
    <link href="http://blog.holten.com/2016/03/17/iterm2-with-ohmyzsh/"/>
    <id>http://blog.holten.com/2016/03/17/iterm2-with-ohmyzsh/</id>
    <published>2016-03-17T11:55:58.000Z</published>
    <updated>2019-08-22T12:00:21.699Z</updated>
    
    <content type="html"><![CDATA[<p>终于在某东做活动新入手了一台air，看身边小伙伴的mac的终端感觉好炫酷，于是乎准备自己也捯饬捯饬，google了一下，发现了osx平台上的终端神器iTerm2和用来代替bash的oh-my-zsh，试了一下发现是真的好使，谁用谁知道。<br><img src="http://oar4g068j.bkt.clouddn.com/iterm2.png" alt=""></p><a id="more"></a><h4 id="安装iTerm2"><a href="#安装iTerm2" class="headerlink" title="安装iTerm2"></a>安装iTerm2</h4><ol><li>首先你得先下载一个<a href="http://www.iterm2.com/" target="_blank" rel="noopener">iTerm2</a>。</li><li>怎么在osx上安装不用说了，直接copy。</li><li>安装完成。</li></ol><h4 id="安装oh-my-zsh"><a href="#安装oh-my-zsh" class="headerlink" title="安装oh-my-zsh"></a>安装oh-my-zsh</h4><p>直接在iTerm2里面输入：<br><code>sh -c &quot;$(curl -fsSL https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code>即可。</p><blockquote><p>注意啦，执行之前记得先装好git。</p></blockquote><h3 id="到这里其实已经安装完成了，下面是个性化定制的内容"><a href="#到这里其实已经安装完成了，下面是个性化定制的内容" class="headerlink" title="到这里其实已经安装完成了，下面是个性化定制的内容"></a>到这里其实已经安装完成了，下面是个性化定制的内容</h3><h4 id="安装Powerline"><a href="#安装Powerline" class="headerlink" title="安装Powerline"></a>安装Powerline</h4><p>直接在iTerm2里面输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo easy_install pip</span><br><span class="line">pip install powerline-status</span><br></pre></td></tr></table></figure></p><p>安装完成。</p><h4 id="安装字体库"><a href="#安装字体库" class="headerlink" title="安装字体库"></a>安装<a href="https://github.com/powerline/fonts" target="_blank" rel="noopener">字体库</a></h4><p>下载下来之后在终端里执行字体库目录下面的install.sh安装powerline字体。</p><h4 id="设置iTerm-2的字体"><a href="#设置iTerm-2的字体" class="headerlink" title="设置iTerm 2的字体"></a>设置iTerm 2的字体</h4><p>安装完字体库之后，把iTerm 2的偏好设置里的Profile选项卡下面的Text选项卡中里的Regular Font和Non-ASCII Font的字体都设置成 Powerline的字体，喜欢哪个自己选就好了，后面带for powerline的就行。</p><h4 id="安装配色方案"><a href="#安装配色方案" class="headerlink" title="安装配色方案"></a>安装<a href="https://github.com/altercation/solarized" target="_blank" rel="noopener">配色方案</a></h4><ol><li>下载下来之后解压，然后到目录下双击Solarized Dark.itermcolors和Solarized Light.itermcolors两个文件就可以把配置文件导入到iTerm 2里。</li><li>通过load presets选择刚刚安装的配色主题即可。<br>3.<h4 id="安装agnoster主题"><a href="#安装agnoster主题" class="headerlink" title="安装agnoster主题"></a>安装<a href="https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor" target="_blank" rel="noopener">agnoster</a>主题</h4></li><li>下载下来之后解压，然后到目录里面运行install文件，就可以主题安装到<code>~/.oh-my-zsh/themes</code>目录下<br>2）<code>cd</code>切换到用户根目录，打开.zshrc文件，然后将ZSH_THEME后面的字段改为agnoster即可。像这样ZSH_THEME=”agnoster”。</li></ol><h3 id="终于搞完了！"><a href="#终于搞完了！" class="headerlink" title="终于搞完了！"></a>终于搞完了！</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;终于在某东做活动新入手了一台air，看身边小伙伴的mac的终端感觉好炫酷，于是乎准备自己也捯饬捯饬，google了一下，发现了osx平台上的终端神器iTerm2和用来代替bash的oh-my-zsh，试了一下发现是真的好使，谁用谁知道。&lt;br&gt;&lt;img src=&quot;http://oar4g068j.bkt.clouddn.com/iterm2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="shell" scheme="http://blog.holten.com/categories/shell/"/>
    
    
      <category term="Setup" scheme="http://blog.holten.com/tags/Setup/"/>
    
      <category term="shell" scheme="http://blog.holten.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>Java利用Rxtx进行串口通讯</title>
    <link href="http://blog.holten.com/2015/12/05/rxtx-comm/"/>
    <id>http://blog.holten.com/2015/12/05/rxtx-comm/</id>
    <published>2015-12-05T08:04:02.000Z</published>
    <updated>2019-08-22T12:00:21.699Z</updated>
    
    <content type="html"><![CDATA[<p>最近在做传感器数据采集的工作，底层是基于Zigbee的无线传感网络，所有数据采集到Zigbee协调器上然后通知上位机数据采集完成，上位机通过USB转串口去读取数据就可以了。那么问题来了，如何进行串口通讯呢？老板说你用Java写个程序好了嘛，用Java写串口程序也是醉了。实验室也没别人写了，所以就让我写了。当我听到要让我用Java写串口通讯程序的时候我本来是拒绝的，然后。。。就没有然后了。。就只能写了。</p><p>网上看了一下，最后用了一个开源的Java串口通讯库RXTX做串口通讯，下面记录一下RXTX的使用方法。</p><a id="more"></a><h4 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h4><p>RXTX做串口通讯，有一个jar包(RXTXcomm.jar)和一个rxtxSerial.dll(Windows环境下)或者librxtxSerial.so（Linux环境下），因为开发是在Windows上，但是工作是在Linux上，所以两个都用到了。</p><p><strong>Windows环境下</strong></p><p>文档里是这么写的</p><blockquote><p>Copy rxtxSerial.dll —&gt; <java_home>\jre\bin</java_home></p></blockquote><p>但是这个做了之后并不能用，会有一些很奇怪的问题，不知道是不是我的Java环境配置有问题还是怎么了，我是把dll文件copy到了C:\Windows\System32，然后一切正常，一直很奇怪，为什么要cp到<java_home>\jre\bin呢？求解答！</java_home></p><p><strong>Linux环境下</strong></p><blockquote><p>Copy librxtxSerial.so —&gt; <java_home>/jre/lib/i386/</java_home></p><p>or</p><p>Copy librxtxSerial.so —&gt; <java_home>/jre/lib/x86_64/</java_home></p></blockquote><p>这个按照文档没问题。</p><p><strong>小问题</strong></p><p>我用的是rxtx-2.2pre2版本的，文档里有写运行时会报版本不匹配的WARNING，实际使用中的确也是这样的，不过目前还没有别的问题，不影响使用。</p><p><br></p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>1.查找端口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * 查找所有可用端口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 所有端口列表</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;String&gt; <span class="title">findPort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Enumeration&lt;CommPortIdentifier&gt; portList = CommPortIdentifier.getPortIdentifiers();<span class="comment">//获得所有串口</span></span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; portNameList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//串口名字添加到List并返回</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (portList.hasMoreElements()) &#123;</span><br><span class="line"></span><br><span class="line">            String portName = portList.nextElement().getName();</span><br><span class="line"></span><br><span class="line">            portNameList.add(portName);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> portNameList;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2.打开端口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 打开串口</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> portName 端口名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> baudrate 波特率</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 串口对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> SerialPort <span class="title">openPort</span><span class="params">(String portName, <span class="keyword">int</span> baudrate)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过端口名识别端口</span></span><br><span class="line"></span><br><span class="line">        CommPortIdentifier portIdentifier = CommPortIdentifier.getPortIdentifier(portName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开端口，并给端口名字和一个timeout</span></span><br><span class="line"></span><br><span class="line">        CommPort commPort = portIdentifier.open(portName, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是不是串口</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (commPort <span class="keyword">instanceof</span> SerialPort) &#123;</span><br><span class="line"></span><br><span class="line">            SerialPort serialPort = (SerialPort) commPort;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//设置一下串口的波特率等参数</span></span><br><span class="line"></span><br><span class="line">                serialPort.setSerialPortParams(baudrate, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (UnsupportedCommOperationException e) &#123;</span><br><span class="line"></span><br><span class="line">                LOGGER.error(<span class="string">"Set Serialport Parameters failure"</span>, e);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"Open "</span> + portName + <span class="string">" sucessfully !"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> serialPort;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            LOGGER.error(<span class="string">"This port is not a serialport"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchPortException | PortInUseException e) &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.error(<span class="string">"There is no "</span> + portName + <span class="string">"or it's occupied!"</span>, e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.发送数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 发送数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> serialPort 串口对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> order      命令字节</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendToPort</span><span class="params">(SerialPort serialPort, <span class="keyword">byte</span>[] order)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        OutputStream out = serialPort.getOutputStream();</span><br><span class="line"></span><br><span class="line">        out.write(order);</span><br><span class="line"></span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.error(<span class="string">"Send to SerialPort failure"</span>, e);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.读取数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 读取数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 字节ArrayList</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] readFromPort(InputStream inStream) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] bytes = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取buffer里的数据长度</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> bufflenth = inStream.available();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == bufflenth) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[bufflenth];</span><br><span class="line"></span><br><span class="line">            inStream.read(bytes);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.error(<span class="string">"Read Data Failure"</span>, e);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bytes;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br>  </p><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p>1.实现监听器</p><p>继承SerialPortEventListener然后重写serialEvent,然后再各个对应case里面写代码就好啦。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExample</span> <span class="keyword">implements</span> <span class="title">SerialPortEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialEvent</span><span class="params">(SerialPortEvent serialPortEvent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (serialPortEvent.getEventType()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SerialPortEvent.BI: <span class="comment">// 10通讯中断</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SerialPortEvent.OE: <span class="comment">// 7溢位错误</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SerialPortEvent.FE: <span class="comment">// 9帧错误</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SerialPortEvent.PE: <span class="comment">// 8奇偶校验错</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SerialPortEvent.CD: <span class="comment">// 6载波检测</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SerialPortEvent.CTS: <span class="comment">// 3清除发送</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SerialPortEvent.DSR: <span class="comment">// 4数据设备准备好</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SerialPortEvent.RI: <span class="comment">// 5振铃指示</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SerialPortEvent.OUTPUT_BUFFER_EMPTY: <span class="comment">// 2输出缓冲区已清空</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SerialPortEvent.DATA_AVAILABLE: <span class="comment">// 1读到可用数据时激活</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.给串口添加监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 添加监听器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> port     串口对象</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> listener 串口监听器</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(SerialPort port, SerialPortEventListener listener)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给串口添加监听器</span></span><br><span class="line"></span><br><span class="line">        port.addEventListener(listener);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置当有数据到达时唤醒监听接收线程</span></span><br><span class="line"></span><br><span class="line">        port.notifyOnDataAvailable(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        port.notifyOnBreakInterrupt(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Add listeners to "</span> + port.getName() + <span class="string">" sucessfully !"</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (TooManyListenersException e) &#123;</span><br><span class="line"></span><br><span class="line">        LOGGER.error(<span class="string">"There is too many listeners !"</span>, e);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TIP"><a href="#TIP" class="headerlink" title="TIP"></a>TIP</h4><p><strong> 一定记得从串口发指令取数据之后加一个延时，等待底层数据传输完成再去buffer里面取，不然很大可能数据包不完整。 </strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在做传感器数据采集的工作，底层是基于Zigbee的无线传感网络，所有数据采集到Zigbee协调器上然后通知上位机数据采集完成，上位机通过USB转串口去读取数据就可以了。那么问题来了，如何进行串口通讯呢？老板说你用Java写个程序好了嘛，用Java写串口程序也是醉了。实验室也没别人写了，所以就让我写了。当我听到要让我用Java写串口通讯程序的时候我本来是拒绝的，然后。。。就没有然后了。。就只能写了。&lt;/p&gt;
&lt;p&gt;网上看了一下，最后用了一个开源的Java串口通讯库RXTX做串口通讯，下面记录一下RXTX的使用方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.holten.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.holten.com/tags/Java/"/>
    
      <category term="串口" scheme="http://blog.holten.com/tags/%E4%B8%B2%E5%8F%A3/"/>
    
      <category term="Rxtx" scheme="http://blog.holten.com/tags/Rxtx/"/>
    
  </entry>
  
  <entry>
    <title>CentOS下通过源码安装最新版Git</title>
    <link href="http://blog.holten.com/2015/12/05/git-install-with-source/"/>
    <id>http://blog.holten.com/2015/12/05/git-install-with-source/</id>
    <published>2015-12-05T06:53:30.000Z</published>
    <updated>2019-08-22T12:00:21.699Z</updated>
    
    <content type="html"><![CDATA[<h4 id="下载源码"><a href="#下载源码" class="headerlink" title="下载源码"></a>下载源码</h4><p>到Git的Github主页上下载最新的源码到本地，解压并进入目录。</p><h4 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 你的git源码目录</span><br><span class="line">autoconf</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="第一个报错"><a href="#第一个报错" class="headerlink" title="第一个报错"></a>第一个报错</h4><p><strong>报错内容：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">usr/bin/perl Makefile.PL PREFIX=<span class="string">'/usr/local/git'</span> INSTALL_BASE=<span class="string">''</span> --localedir=<span class="string">'/usr/local/git/share/locale'</span></span><br><span class="line">Can<span class="string">'t locate ExtUtils/MakeMaker.pm in @INC (@INC contains: /usr/local/lib64/perl5 /usr/local/share/perl5 /usr/lib64/perl5/vendor_perl /usr/share/perl5/vendor_perl /usr/lib64/perl5 /usr/share/perl5 .) at Makefile.PL line 3.</span></span><br><span class="line"><span class="string">BEGIN failed--compilation aborted at Makefile.PL line 3.</span></span><br><span class="line"><span class="string">make[1]: *** [perl.mak] Error 2</span></span><br><span class="line"><span class="string">make: *** [perl/perl.mak] Error 2</span></span><br></pre></td></tr></table></figure></p><p><strong>解决方法：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install perl-ExtUtils-MakeMaker package</span><br></pre></td></tr></table></figure></p><h4 id="第二个报错"><a href="#第二个报错" class="headerlink" title="第二个报错"></a>第二个报错</h4><p><strong>报错内容：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tclsh failed; using unoptimized loading</span><br><span class="line">MSGFMT    po/bg.msg make[1]: *** [po/bg.msg] 错误 127</span><br></pre></td></tr></table></figure></p><p><strong>解决方法：</strong><br>yum install tcl  build-essential tk gettext</p><h4 id="继续编译安装"><a href="#继续编译安装" class="headerlink" title="继续编译安装"></a>继续编译安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>终于世界清净了</p><h4 id="建立软链接"><a href="#建立软链接" class="headerlink" title="建立软链接"></a>建立软链接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/bin/git /usr/bin</span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><p>出现了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git version 2.6.0.GIT</span><br></pre></td></tr></table></figure></p><p>至此，<strong>安装完成</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;下载源码&quot;&gt;&lt;a href=&quot;#下载源码&quot; class=&quot;headerlink&quot; title=&quot;下载源码&quot;&gt;&lt;/a&gt;下载源码&lt;/h4&gt;&lt;p&gt;到Git的Github主页上下载最新的源码到本地，解压并进入目录。&lt;/p&gt;
&lt;h4 id=&quot;编译安装&quot;&gt;&lt;a href=&quot;#编译安装&quot; class=&quot;headerlink&quot; title=&quot;编译安装&quot;&gt;&lt;/a&gt;编译安装&lt;/h4&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; 你的git源码目录&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;autoconf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;./configure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Git" scheme="http://blog.holten.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://blog.holten.com/tags/Git/"/>
    
      <category term="安装" scheme="http://blog.holten.com/tags/%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>Linux环境下RPM方式JDK安装及配置</title>
    <link href="http://blog.holten.com/2015/11/25/jdk-install/"/>
    <id>http://blog.holten.com/2015/11/25/jdk-install/</id>
    <published>2015-11-25T05:48:22.000Z</published>
    <updated>2019-08-22T12:00:21.699Z</updated>
    
    <content type="html"><![CDATA[<h4 id="jdk下载"><a href="#jdk下载" class="headerlink" title="jdk下载"></a>jdk下载</h4><p>这个到java的<a href="http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html" target="_blank" rel="noopener">官方网站</a>下载自己需要的版本就好了，这里下载了jdk1.7版本的，选择下载了rpm包jdk-7u79-linux-x64.rpm。<br><br></p><h4 id="rpm安装"><a href="#rpm安装" class="headerlink" title="rpm安装"></a>rpm安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jdk安装包的目录/jdk-7u79-linux-x64.rpm</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong><em>解释一下：</em></strong><br>-i,–install  表示安装软件包 install package(s)<br>-v,–verbose  表示安装过程中输出软件包更多的信息 provide more detailed output<br>-h,–hash     表示显示安装进度 print hash marks as package installs (good with -v)<br><br></p><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在最后添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.7.0_79</span><br><span class="line">export JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/lib</span><br></pre></td></tr></table></figure></p><p>保存文件，然后执行以下命令使配置文件生效即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure></p><p>最后测试一下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># java -version</span><br><span class="line">java version &quot;1.7.0_79&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.7.0_79-b15)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 24.79-b02, mixed mode)</span><br></pre></td></tr></table></figure></p><p><strong>至此，安装完成！</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;jdk下载&quot;&gt;&lt;a href=&quot;#jdk下载&quot; class=&quot;headerlink&quot; title=&quot;jdk下载&quot;&gt;&lt;/a&gt;jdk下载&lt;/h4&gt;&lt;p&gt;这个到java的&lt;a href=&quot;http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;官方网站&lt;/a&gt;下载自己需要的版本就好了，这里下载了jdk1.7版本的，选择下载了rpm包jdk-7u79-linux-x64.rpm。&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h4 id=&quot;rpm安装&quot;&gt;&lt;a href=&quot;#rpm安装&quot; class=&quot;headerlink&quot; title=&quot;rpm安装&quot;&gt;&lt;/a&gt;rpm安装&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;rpm -ivh jdk安装包的目录/jdk-7u79-linux-x64.rpm&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://blog.holten.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://blog.holten.com/tags/Java/"/>
    
      <category term="安装" scheme="http://blog.holten.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="jdk" scheme="http://blog.holten.com/tags/jdk/"/>
    
  </entry>
  
  <entry>
    <title>用Hexo搭建属于自己的Blog</title>
    <link href="http://blog.holten.com/2015/11/17/hexo-setup/"/>
    <id>http://blog.holten.com/2015/11/17/hexo-setup/</id>
    <published>2015-11-17T07:15:21.000Z</published>
    <updated>2019-08-22T12:00:21.699Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是Hexo"><a href="#什么是Hexo" class="headerlink" title="什么是Hexo"></a>什么是Hexo</h4><p>简单的来说，Hexo是一款基于Node.JS的静态博客框架，官方给它的描述是“A fast, simple &amp; powerful blog framework”。据说它是出自台湾大学生Tommy Chen之手，官方网站是<a href="https://hexo.io" target="_blank" rel="noopener">https://hexo.io</a>，不由感叹台湾大学生的创造力，当然大陆的大学生也是很厉害的，只不过表现在不同方面而已。说远了，言归正传，它有什么特殊之处呢，我没有怎么接触过Node.JS，所以在其代码方面没有什么发言权，就说一下使用上的特点，首先生成速度非常快，可以使用Markdown进行编辑，操作非常简单，一键生成部署到GitHub Pages等（当然自己有空间的部署在自己的空间上也是OK的），所有平台可用，还有好多主题啊、插件啊之类的。<br><a id="more"></a><br><br></p><h4 id="我为什么用Hexo"><a href="#我为什么用Hexo" class="headerlink" title="我为什么用Hexo"></a>我为什么用Hexo</h4><p>当初准备搭建个人Blog时是准备在GitHub上搭建，省时省钱省力，GitHub推荐的是使用Jekyll，也是一款静态博客框架，了解了一下它是基于Ruby开发的，之前完全没有接触过Ruby，又不想单单为了写个Blog再去从头学Ruby，倒腾了一上午发现太麻烦了，偶然间发现了Hexo，感觉还挺不错，看了一下文档发现还是非常easy的，于是乎就用了Hexo。<br><br></p><h4 id="Hexo的安装步骤"><a href="#Hexo的安装步骤" class="headerlink" title="Hexo的安装步骤"></a>Hexo的安装步骤</h4><p>网上有很多Hexo的安装教程，为什么还要写呢，主要是我发现网上教程有些地方写的不是很明白，同时也是做一下记录吧。</p><h5 id="1-安装环境"><a href="#1-安装环境" class="headerlink" title="1. 安装环境"></a>1. 安装环境</h5><ul><li>Windows10 64bit</li><li>Node 4.2.2</li><li>npm 2.14.7</li><li>Hexo 3.1.1</li></ul><h5 id="2-Node环境安装"><a href="#2-Node环境安装" class="headerlink" title="2. Node环境安装"></a>2. Node环境安装</h5><ul><li>Windows上直接到<a href="https://nodejs.org" target="_blank" rel="noopener">官网</a>上下载安装包打开安装就OK了。</li><li>Linux上也是下载对应的编译好的包，然后解压，解压完之后进入bin目录执行就可以了，如果嫌麻烦可以建立一下链接：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ln -s node目录/bin/node /usr/local/bin/node</span><br><span class="line">ln -s node目录/bin/npm /usr/local/bin/npm</span><br></pre></td></tr></table></figure></li></ul><p>下面可以用<code>npm version</code>命令试一下有没有安装成功，成功的话会有如下显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ npm version</span><br><span class="line">&#123; &apos;hexo-site&apos;: &apos;0.0.0&apos;,</span><br><span class="line">  npm: &apos;2.14.7&apos;,</span><br><span class="line">  ares: &apos;1.10.1-DEV&apos;,</span><br><span class="line">  http_parser: &apos;2.5.0&apos;,</span><br><span class="line">  icu: &apos;56.1&apos;,</span><br><span class="line">  modules: &apos;46&apos;,</span><br><span class="line">  node: &apos;4.2.2&apos;,</span><br><span class="line">  openssl: &apos;1.0.2d&apos;,</span><br><span class="line">  uv: &apos;1.7.5&apos;,</span><br><span class="line">  v8: &apos;4.5.103.35&apos;,</span><br><span class="line">  zlib: &apos;1.2.8&apos; &#125;</span><br></pre></td></tr></table></figure></p><p>到此，node环境就安装完成了。</p><h5 id="3-使用npm安装Hexo"><a href="#3-使用npm安装Hexo" class="headerlink" title="3. 使用npm安装Hexo"></a>3. 使用npm安装Hexo</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure><p>然后用<code>hexo version</code>命令可以确认一下有没有安装成功，成功的话会有如下显示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ hexo version</span><br><span class="line">hexo: 3.1.1</span><br><span class="line">os: Windows_NT 10.0.10240 win32 x64</span><br><span class="line">http_parser: 2.5.0</span><br><span class="line">node: 4.2.2</span><br><span class="line">v8: 4.5.103.35</span><br><span class="line">uv: 1.7.5</span><br><span class="line">zlib: 1.2.8</span><br><span class="line">ares: 1.10.1-DEV</span><br><span class="line">icu: 56.1</span><br><span class="line">modules: 46</span><br><span class="line">openssl: 1.0.2d</span><br></pre></td></tr></table></figure></p><p>到此，Hexo就<strong>安装完成</strong>啦。</p><p>如何使用的部分，下一篇再写吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;什么是Hexo&quot;&gt;&lt;a href=&quot;#什么是Hexo&quot; class=&quot;headerlink&quot; title=&quot;什么是Hexo&quot;&gt;&lt;/a&gt;什么是Hexo&lt;/h4&gt;&lt;p&gt;简单的来说，Hexo是一款基于Node.JS的静态博客框架，官方给它的描述是“A fast, simple &amp;amp; powerful blog framework”。据说它是出自台湾大学生Tommy Chen之手，官方网站是&lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://hexo.io&lt;/a&gt;，不由感叹台湾大学生的创造力，当然大陆的大学生也是很厉害的，只不过表现在不同方面而已。说远了，言归正传，它有什么特殊之处呢，我没有怎么接触过Node.JS，所以在其代码方面没有什么发言权，就说一下使用上的特点，首先生成速度非常快，可以使用Markdown进行编辑，操作非常简单，一键生成部署到GitHub Pages等（当然自己有空间的部署在自己的空间上也是OK的），所有平台可用，还有好多主题啊、插件啊之类的。&lt;br&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://blog.holten.com/categories/Hexo/"/>
    
    
      <category term="安装" scheme="http://blog.holten.com/tags/%E5%AE%89%E8%A3%85/"/>
    
      <category term="Hexo" scheme="http://blog.holten.com/tags/Hexo/"/>
    
      <category term="教程" scheme="http://blog.holten.com/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="Setup" scheme="http://blog.holten.com/tags/Setup/"/>
    
  </entry>
  
</feed>
